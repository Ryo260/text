# 2019/10/02
## 自習
### 復習
####本知識
	1. メソッドの引数が同じ型の場合可変長引数が使える
	String method (String a , int .....math){
	//.....が渡せる引数の数
	2. Javadoc
	HTMLでのドキュメントとしてかける。
	/**
	*「ここにかく
	*/
	
	}
#### 015-Javaの基本-配列のネスト
実行すると
90
70
になる。
[][]の一つ目の[]は三つある{}のどれかを指し示し、二つ目は{}内で
何番目かをさす。
	    public static void main(String[] args) {
	        int score[][] = {{ 100, 80, 90, 90 },
	                            { 90, 90, 90, 90 },
	                            { 60, 90, 80, 70 } };
	        System.out.println(score[0][3]);
	        System.out.println(score[2][3]);
	    }
#### .lengthについて
配列名.lengthで配列の要素数を取得する。
	int n[] = {18, 29, 36, 12};
	System.out.println(n.length);
多次元配列の場合、
①以下の場合
2
	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num.length);

②以下の場合
3
3

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num[0].length);
	System.out.println(num[1].length);

さらに配列のネストが深くなるとnum[i][j].lengthになる？
	
#### newについて
newがインスタンスの生成時にクラス名 オブジェクト名= new クラス名()で使用することは理解しているが、
	ABC abc = new ABC();
配列の宣言時にも使用することができる。
	int abc[];	//またはint[] abc;
	abc = new int[5]
配列の宣言とインスタンスの生成に同じnewを使う理由がよくわからんので調べた。

「Let's プログラミング」(https://www.javadrive.jp/start/array/index2.html)
>変数の場合は宣言するだけで一つの値を格納できる場所が確保されましたが、  
配列の場合では値を格納する場所を必要な数だけ後から確保する必要があります。  
場所を確保するにはnew演算子を使って次のように行います。  

宣言ではなく値を格納する場所を確保しているらしい。


「働いたら負け」(http://mikado.hatenablog.jp/entry/2014/06/07/170407)
>”new”が何を表すのか一言で言うとメモリ内に変数（コンストラクタ）を
扱うための領域（オブジェクト領域）を作成します。
	String array = new String[3];
変数の宣言でarrayを扱う領域が確保される。
newString[3]で実データを扱うための領域を新たにメモリ内に確保。
確保した領域の場所をarrayに代入して、arrayが配列として使える。


「Javaでインスタンスを使う方法【初心者向け】」(https://techacademy.jp/magazine/17543)

	PersonalInfo p1 = new PersonalInfo();
newをすることでメモリ内にPersonalInfoクラスと同じ構造の領域を確保され、
その領域をp1と呼ぶ。

- 結論：newはメモリの領域を確保する


#### 016-Javaの基本-配列のネストとfor文


	public class ExampleArrayNestFor {
	    public static void main(String[] args) {
	         int score[][] = { { 100, 80, 90, 90 },
	                             { 90, 90, 90, 90 },
	                             { 60, 90, 80, 70 } };
	         String label[] = { "Tom", "John", "Mary" };
	         for (int i = 0; i < score.length; i++) {
	              System.out.print(label[i] + "'s score:");
	              for (int j = 0; j < score[i].length; j++) {
	                   System.out.print(score[i][j] + " ");
	              }
	              System.out.println();
	         }
	    }
	}


#### メインメソッドに引数を指定して渡すことができる。

	public static void main(String[] args){
	}
mainメソッドはString型配列の変数argsを引数として受け取る。
javaファイルを呼び出す際に値を入力することで
argsとしてうけとれる。

	java クラスファイル名 値1 値2 ..
	
	
#### 017-Javaの基本-mainメソッドの引数
コマンドプロンプトで以下の文を入力
	java クラスファイル名 値1 値2 
二つの値を記載して入力すると合計した値が計算される。


	public class MainMethodArgument {
	     public static void main(String[] args) {
	          if (args.length != 2) {
	               System.out.println("Please set two arguments.");
	               System.exit(0);
	          }
	          int data1 = Integer.parseInt(args[0]);
	          int data2 = Integer.parseInt(args[1]);
	          System.out.println(data1 + data2);
	     }
	}
#### 025-オブジェクト指向の基本-メソッドのオーバーロード
	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product();
	          System.out.println(product1.getPrice());
	          Product product2 = new Product();
	          System.out.println(product2.getPrice(10));
	     }
	}

	class Product {
	     private int price = 10000;

	     public int getPrice() {
	          return this.price;
	     }

	     public int getPrice(double rate) {
	          return (int) (this.price * (100 - rate) / 100);
	     }
	}

# 2019/10/01
## 自習

	package main;

	import java.util.Timer;
	import java.util.TimerTask;

	public class SampleTimer{

		public class SampleTimer{

			public static void main(String[] args){
				System.out.println("タスクを3秒後に実行されるようにセットしました。");
				//ここの記載方法が不明！！なによこのかきかた
				TimerTask task = new TimerTask(){
					public void run(){
						System.out.println("タスクが実行されました");
					}
				};

				Timer timer = new Timer();
				timer.schedule(task,3000);
			}
	
## アサートの失敗
システムパスの信号線において、それが有効な状態にあることをアサートという  
無効な状態にあることをネゲートという  

何故そんな言葉があるのか、それは以下の理由による。  
信号線が有効(オン)になった状態と無効(オフ)になった状態を実際の  
電気回路で実現する場合、  
1. 電圧レベルの高い状態をオン、低い状態をオフ  
1. 電圧レベルの低い状態をオン、高い状態をオフ  
上記の二通りがある。 
実際の電圧レベルの信号の状態で言い表すことは  
ややこしくなってしまうので、有効か無効かを表す言葉がある  

# 2019/09/20
## 自習
### java復習
復習cast
変換が微妙なので再度復習

	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = i / j;

		System.out.println("result = " + result)
この場合実行すると  
result = 3.0になる  
resultの型がfloatなので3.3333になりそうだが、  
計算している変数がともにintのため、計算結果もint型になり切り捨てられる。  
小数点以下を計算したいのであれば変数i,jをfloat型で宣言する。  
  
キャスト変換を利用するのであれば  
	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = (float)i /(float) j;

		System.out.println("result = " + result)
上記のようになる。(型)を変数名の前に着ける。  






for文は覚えている？  
for( i = 0 ; i<10 ; i++){

}
拡張for文は？
拡張for文とは配列のためのfor文。
以下のようになる
	for(データ型 変数名:配列名){
	}
	
	String [] names = ("John", "Kate" , "Bob"};
	for(String name : names){
		System.out.println(name);
	}

配列namesに入っている要素すべてを出力する
	
	通常のfor文で書くとすると
	
	String [] names = ("John", "Kate" , "Bob"};
	for(int i = 0; i<3;i++){
		System.out.println(names[i]
	}
	//自分でかけたぜ！



# 2019/09/20
## 自習
### java配列
	型[] 変数名 = {};

	int[] numbers = { 5,13,29};
	String[] names ={"John","Kate","Bob"};

配列の要素には前から順に「0,1,2」と番号が割り振られている

これをインデックス番号と呼ぶ。  

配列の各要素は配列名[インデックス番号]とすることで取得できる。  
	System.out.println(numbers[1]);

### 配列とfor文

配列namesの要素を全て出力するために、以下のようにいちいち全て書くのは非効率。
	①	String[] names ={"John","Kate","Bob"};
		System.out.println("Hello" + names[0]);
		System.out.println("Hello" + names[1]);
		System.out.println("Hello" + names[2]);

これを短く変更すると②になる  
	②	String[] names ={"John","Kate","Bob"};
		for(int i=0; i < 3;i++){
			System.out.println("Hello" + names[i]);
		}  
拡張性を増やすならば？要素数が増えても対応できるようにしよう。  
	③	String[] names ={"John","Kate","Bob"};
		for(int i=0; i< names.length;i++){
			System.out.println("Hello" + names[i]);
		}
# 2019/09/18
## 自習

### 課題
ボーナス額の計算
//月給*ボーナス
//Scannerは「a b」の入力があった場合、1度のnext()の呼び出しで
//空白までを受け取る。よって今回の場合、1度目の呼び出しで「a」を
//2度目の呼び出しで「b」  

	import java.util.*;


	public class Main {
	    public static void main(String[] args) {！

	        Scanner sc = new Scanner(System.in);
	        int num1 = sc.nextInt();
	        int num2 = sc.nextInt();
	        
	        System.out.println(num1 * num2);
	    }
	}
### 桁計算
	package java0910;

	public class Main {
	    public static void main(String[] args) {

	/*     
		//入力値の桁を出力するプログラム
		//書いたけどだめだったやつ
		System.out.println("計算を行います");
		int a= 10000;
		int n =0;
		int keta =0;
		for(keta=a; keta<1; n ++){
		 keta=    keta/10;
		}
		System.out.print("出力結果：");
		System.out.println(n);
	*/
		//正解
		int val =100;
		int valen = String.valueOf( val).length();
		System.out.println(valen);
	}


	}
# 2019/09/17
## 自習

https://www.saycon.co.jp/touchtype/
https://www.techscore.com/tech/DesignPattern/Iterator/Iterator1.html/

## 写経
	1.1		Itaratorパターン
	繰り返す=Itarator
集約オブジェクト 
「Listクラス」
	要素としていくつかのオブジェクトを持つことができるものとする。
	このListオブジェクトが持つ要素に順番にアクセスするような場合、どのような順番で
	各要素にアクセスするのかによってさまざまな走査方法が考えられる。
	①何らかのパラメータを利用して走査
	②各オブジェクトの名前の順
	この「走査方法」はだれが提供するのか。
	Listクラスですべて提供するのは不可能。
	酔って走査方法を提供するクラスを独立させる。
	
	必要な操作方法を与えるクラスを自分で作成すし、利用することで
	柔軟な設計となる。
	
	また集約オブジェクトとして利用するクラスを変更する必要が生じた際、
	その変更が多くの部分に影響を与えるようなことが考えられる
	
	public class Student{
		private String name;
		private int sex: //男の子:1 女の子:2
		
		public Student(String name.int sex){
			this.name = name;
			this.sex = sex;
		}
		public String getName(){
			return name;
		}
		public int getSex(){
			return sex;
		}
	
生徒は名前、性別を表すメンバ変数name、sexを持ち、名前を返すgetName()メソッドと
性別を返すgetSex()メソッドを持ちます。これらの生徒を管理するために学校から先生に
名簿が支給されます。学校から与えられる名簿は以下のように記述されています。


