## 映画Pにまつわる彼女との話
今現在Pという新作映画が世界中で大ヒットしているらしい。  
○○賞を取ることが確実だとか、  
主演俳優が何キロダイエットしただとかが、  
俺のニュースキュレーションアプリで表示されている。  
俺も毎日のように記事を読まされていると映画が見たくなり、  
今週末の土日に友人と見に行くことになっている。  


映画はまだ見る前なのでその内容については後日考えるとして  
心が揺さぶられた事件が、この前彼女と二人でいるときに起きたので  
備忘録として残しておく。  


もともとこのPという映画は彼女が紹介してくれたものだった。  
twitterかなんかで調べていて  
「こんな映画あるんだねー」  
「でも暴力的かもしんないし彼女は見れないね」  
「ホラーじゃなきゃいけるよ」とかなんとか。  


5日後くらいに行くことを決めた。理由は下記。  
- 宣伝広告で泣きながら化粧をしている主人公の画が心にきた。  
- 世間から虐げられた主人公の復讐劇は面白い  
- twitterとかニュースで絶賛されていたから
- 「今年一番」「映画史の文脈に刻まれる」みたいなフレーズにやられた


それで俺が心に残った事件は以下の彼女と会話の中で起きた。  
彼女「何でそんなに見たくなったの？」  
俺「映画史の文脈に刻まれる作品っぽいんだよね。これは見とかなくちゃって」  
彼女「その言葉twitterでみたわ(笑)」  
俺「俺も見たかも。ってか(彼女)がみせてくれたやつじゃね？(彼女）が紹介してくれたんじゃね？」  
- この最後の言葉が俺の面白くない部分（平子ってる）。  
- ここで彼女がしたいことは俺の安直なミーハーさを皮肉って笑うこと。


twitterやニュースサイトで書かれているありきたりな
映画評論を本気で真面目にさも自分で考えたかのように
他人に語っている俺の愚かさを笑いにしようとしたら、
俺が「単なる受売りのつもりで最初から話してましたよ」感を出してしまっている。
しかも話したこと自体は事実に基づいているせいで
可笑しさをつぶし、話した彼女側が変なことを言ってる感に変えた。


この場面で俺が取るべきだった対応は
1. 自分のミーハーさを認めて、相手に伝わる自分なりのミーハーさで返答
	- 「ってtwitterに書いてあった」
	- 「ってメンタリストのDAIGOが言ってた。」
2. 頑なに自分のミーハーさを否定する
	- 「年に1万本映画見てる同じ意見か。凄いね。」
	- 「こないだヴェネチア映画祭で見てそう思ったんだよね。友人の映画監督も同じ風に言っててさ」
3. 図星突かれたと怒る
	- 「俺が自分なりの意見話すことを大事にしてるとかいつも言ってるのに。他人の意見をそのまま自分の意見みたいに話しちゃったことを指摘するんじゃねえ」
4.ふざける
	- 「だってtwitterでみたんだもん」「アカデミー賞ってtwitterの誰だか知らない人の評判みてきまるんでしょ？」「来年からtwiデミー賞になるって聞いたし」


この出来事が起きた理由  
「映画史の文脈に刻まれる」みたいなフレーズが俺の心に強く残った。  
この映画を見ていないが、ニュースの評論で書かれている無敵の人問題とこの映画がリンクする  
みたいな話が気に入って、感情を入れて話してしまったこと。  
強く共感したときは自分の意見と他人の意見が自分の中で曖昧になること。  

結論：強く共感しても人の意見を感情をこめて話す際には、受け売りだよ。ってことを最初に伝えないと他人は可笑しさを感じる。

# 2019/10/11
## 生活習慣
- 22時ごろ布団に入っても寝れない。
	- 以前試したメラトニンは効果があった気がしたが手に入れるのが面倒。日本のサイトで買うと高い……
- 目標：タンパク質摂取量、 61 (体重：kg)×2.3= 140g
- 今飲んでいるプロテイン4杯でタンパク質26g  
	- 1日に朝夜で52g摂取。 
	- 残り98gほど欲しい。食事は昼・夜のみなので1食49g。 



# 2019/10/10
## Jquery
### ajax():ajaxメソッド(成功はdone、失敗はfail)による非同期通信の書式
	$.ajax({
	  type: リクエストタイプ,
	  url:  リクエスト送信先のURL,
	  data: URLのクエリ（パラメータ）,
	}).done(function(data, textStatus, jqXHR){
	  // 成功の場合の処理
	}).fail(function(jqXHR, textStatus, errorThrown){
	  // エラーの場合処理
	});
[ajax()：ajaxメソッド(成功はdone、失敗はfail)による非同期通信](http://karashidaimyojin.com/jquery/ajax-ajax/)

## エレメントとは
- HTML や XML 文書における、要素（タグ）
- ブラウザ画面上に配置して表示できる、DOM オブジェクト

### タグ（要素）はエレメントとなる

	<span>あいうえお</span>
	<div>かきくけこ</div>
	<img src="http://example.com/test.jpg">


### エレメントは、アトリビュート（属性）を管理することができます。
> - 以下のidやwidth,height,srcのこと

	<span id="aaa">あいうえお</span>
	<div width="300" height="200">かきくけこ</div>
	<img src="http://example.com/test.jpg">

### インラインスタイルについて
- エレメントは、スタイル属性（インラインスタイル）を保有。
- スタイル属性を使用すると、エレメントごとに、個別にスタイルを設定することができます。
	<div style="color: #f22; background-color: #fcc; width: 400px; height: 300px;">
		あいうえお
	</div>
- [スタイルについて](https://hakuhin.jp/js/style_declaration.html)

### document.createElement('tr');

  // 新しい div 要素を作成します 
  var newDiv = document.createElement("div"); 
  // いくつかの内容を与えます 
  var newContent = document.createTextNode("Hi there and greetings!"); 
  // テキストノードを新規作成した div に追加します
  newDiv.appendChild(newContent);  




# 2019/10/04
## 自習


### 本日行ったpaizaの問題
- D136:空港の呼称
- D135:【キャンペーン問題】多角形の調査
- D134:タイトルの長さ
- D120:鉛筆の数
- D010:Eメールアドレス
- D081:【キャンペーン問題】家族で分ける

	
>nextLine( )メソッドは空白(スペース)を含む文字列を取得することができます。  
一方next( )メソッドは空白までの文字列を取得します。

資金X円
上昇前A円
上昇後B円

int X
 ((X/A)* B - (X/A) * A)
 



### substring

int num = 1234567

num.substring(x,y)
x+1番目の文字列から
y番目の文字まで切り出す

num.substring(1,4)



# 2019/10/02
## 自習
### 復習
#### 本知識  
1. メソッドの引数が同じ型の場合可変長引数が使える

	String method (String a , int .....math){
	//.....が渡せる引数の数
	}

2. Javadoc
HTMLでのドキュメントとしてかける。

	/**
	*「ここにかく」
	*/

#### 015-Javaの基本-配列のネスト
実行すると
90  
70  
になる。  
[][]の一つ目の[]は三つある{}のどれかを指し示し、二つ目は{}内で
何番目かをさす。  

	    public static void main(String[] args) {
	        int score[][] = {{ 100, 80, 90, 90 },
	                            { 90, 90, 90, 90 },
	                            { 60, 90, 80, 70 } };
	        System.out.println(score[0][3]);
	        System.out.println(score[2][3]);
	    }

#### .lengthについて
配列名.lengthで配列の要素数を取得する。

	int n[] = {18, 29, 36, 12};
	System.out.println(n.length);
#### 多次元配列の場合、  
①以下の場合  
2  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num.length);

②以下の場合  
3  
3  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num[0].length);
	System.out.println(num[1].length);

さらに配列のネストが深くなるとnum[i][j].lengthになる？
	
#### newについて
newがインスタンスの生成時にクラス名 オブジェクト名= new クラス名()で使用することは理解しているが、 

	ABC abc = new ABC();

配列の宣言時にも使用することができる。

	int abc[];	//またはint[] abc;
	abc = new int[5]

配列の宣言とインスタンスの生成に同じnewを使う理由がよくわからんので調べた。

[Let's プログラミング](https://www.javadrive.jp/start/array/index2.html)
>変数の場合は宣言するだけで一つの値を格納できる場所が確保されましたが、  
配列の場合では値を格納する場所を必要な数だけ後から確保する必要があります。  
場所を確保するにはnew演算子を使って次のように行います。  

宣言ではなく値を格納する場所を確保しているらしい。


[働いたら負け](http://mikado.hatenablog.jp/entry/2014/06/07/170407)
>”new”が何を表すのか一言で言うとメモリ内に変数（コンストラクタ）を
扱うための領域（オブジェクト領域）を作成します。
	String array = new String[3];
変数の宣言でarrayを扱う領域が確保される。
newString[3]で実データを扱うための領域を新たにメモリ内に確保。
確保した領域の場所をarrayに代入して、arrayが配列として使える。


[Javaでインスタンスを使う方法【初心者向け】](https://techacademy.jp/magazine/17543)

	PersonalInfo p1 = new PersonalInfo();
newをすることでメモリ内にPersonalInfoクラスと同じ構造の領域を確保され、
その領域をp1と呼ぶ。

- 結論：newはメモリの領域を確保する


#### 016-Javaの基本-配列のネストとfor文


	public class ExampleArrayNestFor {
	    public static void main(String[] args) {
	         int score[][] = { { 100, 80, 90, 90 },
	                             { 90, 90, 90, 90 },
	                             { 60, 90, 80, 70 } };
	         String label[] = { "Tom", "John", "Mary" };
	         for (int i = 0; i < score.length; i++) {
	              System.out.print(label[i] + "'s score:");
	              for (int j = 0; j < score[i].length; j++) {
	                   System.out.print(score[i][j] + " ");
	              }
	              System.out.println();
	         }
	    }
	}

	
#### 017-Javaの基本-mainメソッドの引数

メインメソッドに引数を指定して渡すことができる。

	public static void main(String[] args){
	}
mainメソッドはString型配列の変数argsを引数として受け取る。
javaファイルを呼び出す際に値を入力することで
argsとしてうけとれる。

	java クラスファイル名 値1 値2 ..
コマンドプロンプトで以下の文を入力
	java クラスファイル名 値1 値2 
	
二つの値を記載して入力すると合計した値が計算される。


	public class MainMethodArgument {
	     public static void main(String[] args) {
	          if (args.length != 2) {
	               System.out.println("Please set two arguments.");
	               System.exit(0);
	          }
	          int data1 = Integer.parseInt(args[0]);
	          int data2 = Integer.parseInt(args[1]);
	          System.out.println(data1 + data2);
	     }
	}
#### 025-オブジェクト指向の基本-メソッドのオーバーロード
- 同じメソッド名でも引数を変えることで別の記載を使用することができる。


	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product();
	          System.out.println(product1.getPrice());
	          Product product2 = new Product();
	          System.out.println(product2.getPrice(10));
	     }
	}


	class Product {
	     private int price = 10000;

	     public int getPrice() {
	          return this.price;
	     }

	     public int getPrice(double rate) {
	          return (int) (this.price * (100 - rate) / 100);
	     }
	}
#### 028-オブジェクト指向の基本-クラス変数とクラスメソッド


public class BasicClass {
     public static void main(String[] args) {
          Product product1 = new Product("pencil", 100);
          Product product2 = new Product("eraser", 60);
          System.out.println(Product.getProductCount());
     }
}

class Product {
     private String productName;
     private int price;
     private static int count = 0;

     public Product(String productName, int price) {
          this.productName = productName;
          this.price = price;
          count++;
     }

     public static int getProductCount() {
          return count;
     }
}

# 2019/10/01
## 自習

	package main;

	import java.util.Timer;
	import java.util.TimerTask;

	public class SampleTimer{

		public class SampleTimer{

			public static void main(String[] args){
				System.out.println("タスクを3秒後に実行されるようにセットしました。");
				//ここの記載方法が不明！！なによこのかきかた
				TimerTask task = new TimerTask(){
					public void run(){
						System.out.println("タスクが実行されました");
					}
				};

				Timer timer = new Timer();
				timer.schedule(task,3000);
			}
	
## アサートの失敗
システムパスの信号線において、それが有効な状態にあることをアサートという  
無効な状態にあることをネゲートという  

何故そんな言葉があるのか、それは以下の理由による。  
信号線が有効(オン)になった状態と無効(オフ)になった状態を実際の  
電気回路で実現する場合、  
1. 電圧レベルの高い状態をオン、低い状態をオフ  
1. 電圧レベルの低い状態をオン、高い状態をオフ  
上記の二通りがある。 
実際の電圧レベルの信号の状態で言い表すことは  
ややこしくなってしまうので、有効か無効かを表す言葉がある  

# 2019/09/20
## 自習
### java復習
復習cast
変換が微妙なので再度復習

	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = i / j;

		System.out.println("result = " + result)
この場合実行すると  
result = 3.0になる  
resultの型がfloatなので3.3333になりそうだが、  
計算している変数がともにintのため、計算結果もint型になり切り捨てられる。  
小数点以下を計算したいのであれば変数i,jをfloat型で宣言する。  
  
キャスト変換を利用するのであれば  
	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = (float)i /(float) j;

		System.out.println("result = " + result)
上記のようになる。(型)を変数名の前に着ける。  






for文は覚えている？  
for( i = 0 ; i<10 ; i++){

}
拡張for文は？
拡張for文とは配列のためのfor文。
以下のようになる
	for(データ型 変数名:配列名){
	}
	
	String [] names = ("John", "Kate" , "Bob"};
	for(String name : names){
		System.out.println(name);
	}

配列namesに入っている要素すべてを出力する
	
	通常のfor文で書くとすると
	
	String [] names = ("John", "Kate" , "Bob"};
	for(int i = 0; i<3;i++){
		System.out.println(names[i]
	}
	//自分でかけたぜ！



# 2019/09/20
## 自習
### java配列
	型[] 変数名 = {};

	int[] numbers = { 5,13,29};
	String[] names ={"John","Kate","Bob"};

配列の要素には前から順に「0,1,2」と番号が割り振られている

これをインデックス番号と呼ぶ。  

配列の各要素は配列名[インデックス番号]とすることで取得できる。  
	System.out.println(numbers[1]);

### 配列とfor文

配列namesの要素を全て出力するために、以下のようにいちいち全て書くのは非効率。
	①	String[] names ={"John","Kate","Bob"};
		System.out.println("Hello" + names[0]);
		System.out.println("Hello" + names[1]);
		System.out.println("Hello" + names[2]);

これを短く変更すると②になる  
	②	String[] names ={"John","Kate","Bob"};
		for(int i=0; i < 3;i++){
			System.out.println("Hello" + names[i]);
		}  
拡張性を増やすならば？要素数が増えても対応できるようにしよう。  
	③	String[] names ={"John","Kate","Bob"};
		for(int i=0; i< names.length;i++){
			System.out.println("Hello" + names[i]);
		}
# 2019/09/18
## 自習

### 課題
ボーナス額の計算
//月給*ボーナス
//Scannerは「a b」の入力があった場合、1度のnext()の呼び出しで
//空白までを受け取る。よって今回の場合、1度目の呼び出しで「a」を
//2度目の呼び出しで「b」  

	import java.util.*;


	public class Main {
	    public static void main(String[] args) {！

	        Scanner sc = new Scanner(System.in);
	        int num1 = sc.nextInt();
	        int num2 = sc.nextInt();
	        
	        System.out.println(num1 * num2);
	    }
	}
### 桁計算
	package java0910;

	public class Main {
	    public static void main(String[] args) {

	/*     
		//入力値の桁を出力するプログラム
		//書いたけどだめだったやつ
		System.out.println("計算を行います");
		int a= 10000;
		int n =0;
		int keta =0;
		for(keta=a; keta<1; n ++){
		 keta=    keta/10;
		}
		System.out.print("出力結果：");
		System.out.println(n);
	*/
		//正解
		int val =100;
		int valen = String.valueOf( val).length();
		System.out.println(valen);
	}


	}
# 2019/09/17
## 自習

https://www.saycon.co.jp/touchtype/
https://www.techscore.com/tech/DesignPattern/Iterator/Iterator1.html/

## 写経
	1.1		Itaratorパターン
	繰り返す=Itarator
集約オブジェクト 
「Listクラス」
	要素としていくつかのオブジェクトを持つことができるものとする。
	このListオブジェクトが持つ要素に順番にアクセスするような場合、どのような順番で
	各要素にアクセスするのかによってさまざまな走査方法が考えられる。
	①何らかのパラメータを利用して走査
	②各オブジェクトの名前の順
	この「走査方法」はだれが提供するのか。
	Listクラスですべて提供するのは不可能。
	酔って走査方法を提供するクラスを独立させる。
	
	必要な操作方法を与えるクラスを自分で作成すし、利用することで
	柔軟な設計となる。
	
	また集約オブジェクトとして利用するクラスを変更する必要が生じた際、
	その変更が多くの部分に影響を与えるようなことが考えられる
	
	public class Student{
		private String name;
		private int sex: //男の子:1 女の子:2
		
		public Student(String name.int sex){
			this.name = name;
			this.sex = sex;
		}
		public String getName(){
			return name;
		}
		public int getSex(){
			return sex;
		}
	
生徒は名前、性別を表すメンバ変数name、sexを持ち、名前を返すgetName()メソッドと
性別を返すgetSex()メソッドを持ちます。これらの生徒を管理するために学校から先生に
名簿が支給されます。学校から与えられる名簿は以下のように記述されています。


