# 2019/10/17
## 自習
### paiza
現在22
- D031:分から秒へ 
- D033:頭文字 
- D008:奇数か偶数か 
- D065:エラーコードの分類
- D115:【エンジニア死滅コラボ問題】おかしの二等分 
- D042:行列
- D027:nまでの和
- D099:短冊づくり
- D111:文字を切り詰める
- D106:割った余り
- D016:N文字目まで出力
- D052:ピラミッドの作り方
- D112:工場の生産力
- D022:表面積の計算
- D110:3つの数字
- D126:点数の計算
- D067:スイッチのオンオフ
- D041:本棚選び
- D091:花粉の予報
- D036:アットマーク
- D105:長さの一致
- D103:逆さ読み★
- D043:天気の表示
- 50/132残り82

### HashMap
[絶対に分かるハッシュマップ](https://qiita.com/ztrehagem/items/32407b3bae8fb92d4baf)
### listとArraylistの違い
[listとArraylistの違い](https://www.sejuku.net/blog/14886)

#### Listとはインターフェースと呼ばれる中小メソッドのみを持ったクラス的なやつ。
単体では使えないので実装する必要がある。インターフェースを実装することで
実装したクラスを使うことができるようになる。

#### ArrayListとは
ArrayListとはlistインターフェースを実装したコレクションクラス

#### 宣言の型はListとArrayListのどちらを使うべきか

##### Listはインターフェースなのでインスタンスの生成ができない

	×List<Integer> list = new List<Integer>();

	○List<Integer> list = new Array<Integer>();

##### ArrayListはListの実装クラスなので以下ができる。

	○ArrayList<Integer> list = new ArrayList<Integer>();
	
##### ではどちらを使うべきか
- 宣言：List,生成：ArrayList
> メリット：ArrayListからLinkedList等別のコレクション(データ型)に変更したい場合宣言時のListには手を加えなくても良い
> デメリット：ArrayListにしかないメソッドを使いたい場合、宣言はListであるため型キャストが必要

### ラムダ式について
#### 基本書式
	(メソッドの引数列) -> {処理内容}

#### 例1
	(int x, int y) -> {return x + y;}

#### 引数の型宣言を省略
	(x,y) -> {return x + y;}
	
#### 1行の記述ですむ場合、「{}」を省略できる
	(x,y) -> return x + y;





### 線形探索(リニアサーチ）
- 先頭から順番に探す値が見つかるまで探していく。
- 配列を直線的(リニア)に探すのでリニアサーチ
#### 目的：配列からある値を探すこと
#### 現状：分かっているのはデータの「個数」「それぞれの値」、「探す値」
#### 結果：「値があるか」「どこにあるか」
#### メリット：単純で実装しやすい
#### デメリット：処理速度が遅い。
#### 内容
- 特徴：探す値が見つかったときはそのデータの「配列番号」は必ず「0以上の整数」
1. 探す値が見つかったときは配列の番号0以上の整数を使う
2. 探す値が見つからなかったときはマイナスの値を使う
#### サンプルソース

	package argo;

	public class ArgoLinearSearch {

	    public static void main(String[] args) {
	        int[] data = {30, 60, 70, 90, 20} ;
	        System.out.println(search(data,70));
	    }
	    public static int search(int[] data , int target){
	        int find = -1;
	        for(int i = 0 ; i < data.length; i++){
	            if(data[i] == target){
	                find = i + 1;
	            }
	        }
	        return find;
	    }

	}

### 二分探索
#### 目的：配列からある値を探すこと
#### 現状：分かっているのはデータの「個数」「それぞれの値」「それぞれの値がソートされている」、「探す値」
#### 結果：「値があるか」「どこにあるか」
#### メリット：処理速度が速い。
#### デメリット：処理が複雑
#### 内容
- data.length == 12;
##### 1回目 
right == 12-1;
mid == 0 + 11 /2 = 5.5 //int型のため切捨て5
if(data[i]==target)の場合
	mid+1が戻り値
else if (target < data[mid])の場合
	right = mid;//探索範囲の右端が真ん中になる
else(target > data[mid])の場合
	left = mid+1//探索範囲の左端が真ん中になる
	
##### 2回目
right == 11
left == mid + 1 //mid==5なのでleft==6

mid == 11+ 6 = 17 //8
target = 140 ;
data[8] = 170;

right = 8



#### サンプルソース
	public class ArgoBinarySearch {
	    public static void main(String[] args){
	        int[] data = {10, 30, 40, 60, 80, 90, 110, 140, 170, 190, 210, 260};
	        System.out.println(search(data,140));
	    }
	    public static int search(int[] data, int target){
	        int find = -1;
	        int left = 0;
	        int right = data.length-1;
	        while(left < right){
	            int mid = (left + right) / 2 ;
	            if(data[mid] == target){
	                return mid + 1;
	            }else if(data[mid] < target) {
	                left = mid + 1;
	            }else {
	                right = mid;
	            }
	        }
	        return find;
	    }
	}
#### 疑問点
- 最後のright = mid;が分からない
- right = mid -1;では何故だめなのか
- data[mid] ==targetの余地をなくしてしまうから？

#### 帰ったら削除
	import java.util.*;


	public class Main {
	    public static void main(String[] args) {

	        Scanner sc = new Scanner(System.in);
	        String line = sc.next();
	        String line2 ="";
	        int num = line.length();
	        for(int i = 0; i < line.length(); i++){
	            line2 =line2.concat(line.substring(num-1,num));
	            num = num-1;
	        }
	        System.out.println(line2);
	    }
	}



# 2019/10/16
## 自習

### super
- 親クラスの引数を持つコンストラクタを呼び出すには、super という命令を使用した
- 以下を追加するとよいかもしれない
-  * @param 
-  * @return
### いろんなメソッド
- 「変数.equals(変数2)」で変数1と変数2の文字列の比較ができる。
	- 文字列であるString型は[別の変数-中身同じ]といったときに変数自体を比較してしまうので「==」はだめ。
	



### jarファイル


- jarファイルとはjarファイルは他のプログラムで使うライブラリや
- Javaアプリの実行ファイルとして使えるので、流用ができて便利です。
jarとは、コンパイルされた複数のclassファイルおよび
それが使用する画像などのリソースを一つにまとめZIP形式で圧縮されたファイル、
もしくはそれを出力するツールのことを言います。Java Archiveの略です。
- jarファイルは実行可能な形式ではない。
- 私のようなプログラミング初学者にとって「アプリケーションを実行する」とは以下である。
	1. アイコンをダブルクリック
	2. 機能が実行される
- しかしjavaの成果物はその段階まで行かず、コマンドラインから実行する必要がある。
- 私が作る場合はその段階まで行いたいので「.exe」形式に変換する。


### 入力した値の数だけ日付を出す
	import java.util.Calendar;
	import java.util.Date;
	import java.util.Scanner;

	public class Calendar1 {
	    public static void main(String[] args){
	        Scanner scan = new Scanner(System.in);
	        int a = scan.nextInt(); 
	        for(int i = 0; i < a; i++){
	            Calendar cal = Calendar.getInstance();
	            cal.add(Calendar.DAY_OF_MONTH, i);
	            Date date = cal.getTime();
	            System.out.println(date);
	        }
	        
	        scan.close();
	    }
	}









### Stringからintに型変換
	public class ExampleString4 {
	    public static void main(String[] args){
	        String inputStr = "10000";
	        //intではなくinteger.parseIntで型変換する
	        //
	        int data = Integer.parseInt(inputStr);
	        System.out.println(data + 500);
	    }
	}



### intからStringに型変換


	public class ExampleInt {
		public static void main(String[] args){
			int num = 10000;
			//
			String str = String.valueOf(num);
			System.out.println("str = " + str);
		}
	}
	
### 時刻の比較


	import java.text.DateFormat;
	import java.text.ParseException;
	import java.text.SimpleDateFormat;
	import java.util.Calendar;
	import java.util.Date;

	public class ExampleDateOld {
	 public static void main(String[] args) {
	      System.out.println(compareDate("2020/01/01"));
	 }

	 public static int compareDate(String date) {
	     
	/*     Calendarクラスはabstractクラスのため直接new演算子で
	 *     オブジェクトを作成することはできない。「getInstance」メソッドを
	 *     使うことでオブジェクト作成することができるようになっている。
	 *     このメソッドを使って取得したCalendarクラスのオブジェクトはデフォルトの
	 *     値としてこのメソッドが実行されたときの日時の情報を取得している
	 *     作成されたオブジェクトから日付情報などを取得することができる
	 *     また、「getInstance」メソッドはstaticメソッドのため
	 *     「Calendar.getInstance()」のように利用する。
	*/     
	      Calendar cal = Calendar.getInstance();

	/*      Calendarクラスのsetメソッドはカレンダーの時刻や日付などの
	 *      要素を設定するときに使用する。
	 *      
	 *      また、Calendarクラスで用意されている定数を指定して、
	 *      年、月、日などの単位ごとまたはまとめて取得することができる
	 *      >HOUR_OF_DAY    時間を24時間単位で表します。
	 *      >MINUTE 分を表します。
	 *      >SECOND 秒を表します。
	 *      >MILLISECOND ミリ秒を表す。
	 *      時間、分、秒、ミリ秒に0をセットしている。
	*/
	      cal.set(Calendar.HOUR_OF_DAY, 0);
	      cal.set(Calendar.MINUTE, 0);
	      cal.set(Calendar.SECOND, 0);
	      cal.set(Calendar.MILLISECOND, 0);
	/*
	 *      CalendarクラスでのgetTime() 
	 *      現在の日時を返す。
	 *      Calendar型からDate型へ変換する場合は、Calendar型の変数に対して、
	 *      getTimeメソッドで現在時刻を取得し、Date型の変数に設定すれば変換できます。
	*/
	      Date currentDate = cal.getTime();
	/*
	 *      DateFormatのサブクラスであるSimpleDateFormatクラスのオブジェクトを生成している。
	 *      子クラスのインスタンスは親クラスの型を持つ変数に代入することができる。
	 *      このときは親クラスの型を持つので子クラスのメソッドを呼び出すことはできないが、
	 *      親クラスのメソッドを呼び出すことができる。
	 *      ただしコンストラクタは生成時に行われるので子クラスのコンストラクタが呼び出されている。
	 *      [継承と型参照](https://java2005.cis.k.hosei.ac.jp/materials/lecture18/polymorphism.html)
	 * 
	 *      @setLenient:日付時刻解析を厳密に行うかどうかを設定する。
	 *      (Lenientとは寛大という意味。「寛大を(false)」)
	 *       例えば2013年に2月29は存在しないが、入力すると、自動的に2013年3月1日と
	 *      判定してくれる。そのときに間違いだと「false」を指摘してくれる記載。
	 *      オブジェクトを生成して、「try{}」の上に書くのが基本。
	 * */
	      DateFormat format = new SimpleDateFormat("yyyy/MM/dd");
	      format.setLenient(false);
	      try {
	/*          parse()　指定された文字列の先頭からテキストを解析して日付を生成します
	 *          引数dateから日付を生成してchekDateに突っ込む
	 *           DateとCalendarの違いとは
	 *           Calendarクラスは、日付や時刻の演算処理を行う機能で、日付の値を細かく計算することができます。
	 *           Dateクラスは、1970年1月1日0時からの経過時間を持ち、主に指定した日付や時間を取得するのに用いられます。
	 *           
	*/
	          Date checkDate = format.parse(date);
	          /*compareToメソッドで日付を比較する場合の戻り値は次の通り
	           * メソッドの呼び出し元の日付が、引数の日付より前の場合は”-1”
	           * メソッドの呼び出し元の日付が、引数の日付より後の場合は”1”
	           * メソッドの呼び出し元の日付が、引数の日付と同じ場合は”0”
	           * return文があるとそこで呼出元に戻り値を返す。
	*/
	           return currentDate.compareTo(checkDate);
	      } catch (ParseException e) {
	           e.printStackTrace();
	      }
	      return -9999;
	 }
	}

### 064:ファイルに文字の入力、ファイルから文字の出力

	import java.io.BufferedReader;
	import java.io.BufferedWriter;
	import java.io.FileReader;
	import java.io.FileWriter;
	import java.io.IOException;

	public class SampleFileIO1 {
	/*  区切り文字について
	 *  windowsでは「\」ではなく「\\」
	*/    
	    public static final String FILE_PATH = "c:\\Users\\80600013\\Desktop\\大西\\01_学習\\01_4_コーディング\\Java\\data.txt";
	    
	         public static void main(String[] args) {
	             /*FileWriterクラスのオブジェクトを作成する場合には
	              * IOExceptionという例外が発生する可能性があるため
	              * 例外の処理をしておく
	              * try()catch(IOException e){)
	              * 
	              * */
	              try {
	                  /*FileWriterについて
	                   * FileWriterクラスは文字を書き込むために使う
	                   * 新しいテキストファイルを作ったり、既に存在する
	                   * テキストファイルに追加で文字を書き込むことができる
	                   * 「FILE_PATH」によってファイルを作成する場所とファイル名を指定
	                   * FileWriterクラスのオブジェクトを作成
	                   * BUrrerdWriterのオブジェクトを作成。
	                   * */
	                   FileWriter fw = new FileWriter(FILE_PATH);
	                   BufferedWriter bw = new BufferedWriter(fw);
	                   /*
	                    * BUrrerdWriterクラスのwriteメソッドを利用して
	                    * ファイルに書き込み
	                    * close()でストリームを閉じる
	                    */
	                   bw.write("Hello, Java!");
	                   bw.close();
	                   /*ここから読込を行っている
	                    * FileReader
	                    * BufferedReader
	                    * */
	                   FileReader fr = new FileReader(FILE_PATH);
	                   BufferedReader br = new BufferedReader(fr);
	                   String data = br.readLine();
	                   br.close();
	                   System.out.println(data);
	              } catch (IOException e) {
	                   e.printStackTrace();
	              }
	         }
	}



### アクセス修飾子
[アクセス修飾子について](https://www.sejuku.net/blog/22679)
| アクセス修飾子 | 同一クラス | 同一パッケージ |サブクラス| 全て|
| -------- |:-------:| -------:|
| public | ○ | ○ | ○ | ○ |
| protected | ○ | ○ | ○ | × |
| 指定なし | ○ | ○ | × | × |
| private | ○ | × | × | × |

### 小数点計算を行った後(型がおそらくdouble)になっているので(int)に戻す
	     private static final double TAX = 0.08;
	     public int getTotalPrice(int price) {
	          return (int) (price * (1 + TAX));
	     }
### 引数の型、数が異なり、同じ名前のメソッド名→オーバーロード
### 「static」がつくクラス変数は大抵、インスタンスの生成を何回やったのかをカウントしてる
	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product("pencil", 100);
	          Product product2 = new Product("eraser", 60);
	          System.out.println(Product.getProductCount());
	     }
	}
	
	class Product {
	     private String productName;
	     private int price;
	     private static int count = 0;
	
	     public Product(String productName, int price) {
	          this.productName = productName;
	          this.price = price;
	          count++;
	     }
	
	     public static int getProductCount() {
	          return count;
	     }
	}

### 032-アルゴリズム-最大値を求める
	public class ArgoMax {
		public static void main(String [] args){
			int[] data = { 30, 60, 70, 90, 20 };
			System.out.print(max(data));
		}
		public int max(int[] data){
			int max = data[0];
			for( i = 1 ; i < data.length ; i++){
				if( max < data[i]){
					max = data[i]
				}
			return max;
			}	

# 2019/10/11
## 自習
### C070:【キャンペーン問題】簡易カードゲームできなかった

package java0905;

	import java.util.*;

	public class Sam {
	    public static void main(String[] args) {
		// 自分の得意な言語で
		// Let's チャレンジ！！

		Scanner sc = new Scanner(System.in);

		String line = sc.next();
		String line2 = sc.next();

		String[] lineArray = new String[line.length()];

		for (int i = 1; i < lineArray.length; i++) {
		    String Rine = String.valueOf(line.charAt(i));
		    lineArray[i] = Rine;
		    System.out.println(lineArray[i]);
		}
	    }
	}

## 映画Pにまつわる彼女との話
今現在Pという新作映画が世界中で大ヒットしているらしい。  
○○賞を取ることが確実だとか、  
主演俳優が何キロダイエットしただとかが、  
俺のニュースキュレーションアプリで表示されている。  
俺も毎日のように記事を読まされていると映画が見たくなり、  
今週末の土日に友人と見に行くことになっている。  


映画はまだ見る前なのでその内容については後日考えるとして  
心が揺さぶられた事件が、この前彼女と二人でいるときに起きたので  
備忘録として残しておく。  


もともとこのPという映画は彼女が紹介してくれたものだった。  
twitterかなんかで調べていて  
「こんな映画あるんだねー」  
「でも暴力的かもしんないし彼女は見れないね」  
「ホラーじゃなきゃいけるよ」とかなんとか。  


5日後くらいに行くことを決めた。理由は下記。  
- 宣伝広告で泣きながら化粧をしている主人公の画が心にきた。  
- 世間から虐げられた主人公の復讐劇は面白い  
- twitterとかニュースで絶賛されていたから
- 「今年一番」「映画史の文脈に刻まれる」みたいなフレーズにやられた


それで俺が心に残った事件は以下の彼女と会話の中で起きた。  
彼女「何でそんなに見たくなったの？」  
俺「映画史の文脈に刻まれる作品っぽいんだよね。これは見とかなくちゃって」  
彼女「その言葉twitterでみたわ(笑)」  
俺「俺も見たかも。ってか(彼女)がみせてくれたやつじゃね？(彼女）が紹介してくれたんじゃね？」  
- この最後の言葉が俺の面白くない部分（平子ってる）。  
- ここで彼女がしたいことは俺の安直なミーハーさを皮肉って笑うこと。


twitterやニュースサイトで書かれているありきたりな
映画評論を本気で真面目にさも自分で考えたかのように
他人に語っている俺の愚かさを笑いにしようとしたら、
俺が「単なる受売りのつもりで最初から話してましたよ」感を出してしまっている。
しかも話したこと自体は事実に基づいているせいで
可笑しさをつぶし、話した彼女側が変なことを言ってる感に変えた。


この場面で俺が取るべきだった対応は
1. 自分のミーハーさを認めて、相手に伝わる自分なりのミーハーさで返答
	- 「ってtwitterに書いてあった」
	- 「ってメンタリストのDAIGOが言ってた。」
2. 頑なに自分のミーハーさを否定する
	- 「年に1万本映画見てる同じ意見か。凄いね。」
	- 「こないだヴェネチア映画祭で見てそう思ったんだよね。友人の映画監督も同じ風に言っててさ」
3. 図星突かれたと怒る
	- 「俺が自分なりの意見話すことを大事にしてるとかいつも言ってるのに。他人の意見をそのまま自分の意見みたいに話しちゃったことを指摘するんじゃねえ」
4. 矢作風にふざける
	- 「だってtwitterでみたんだもん」「アカデミー賞ってtwitterの誰だか知らない人の評判みてきまるんでしょ？」「来年からtwiデミー賞になるって聞いたし」


この出来事が起きた理由  
「映画史の文脈に刻まれる」みたいなフレーズが俺の心に強く残った。  
この映画を見ていないが、ニュースの評論で書かれている無敵の人問題とこの映画がリンクする  
みたいな話が気に入って、感情を入れて話してしまったこと。  
強く共感したときは自分の意見と他人の意見が自分の中で曖昧になること。  

結論：強く共感しても人の意見を感情をこめて話す際には、受け売りだよ。ってことを最初に伝えないと他人は可笑しさを感じる。

# 2019/10/11
## 生活習慣
- 22時ごろ布団に入っても寝れない。
	- 以前試したメラトニンは効果があった気がしたが手に入れるのが面倒。日本のサイトで買うと高い……
- 目標：タンパク質摂取量、 61 (体重：kg)×2.3= 140g
- 今飲んでいるプロテイン4杯でタンパク質26g  
	- 1日に朝夜で52g摂取。 
	- 残り98gほど欲しい。食事は昼・夜のみなので1食49g。 



# 2019/10/10
## Jquery
### ajax():ajaxメソッド(成功はdone、失敗はfail)による非同期通信の書式
	$.ajax({
	  type: リクエストタイプ,
	  url:  リクエスト送信先のURL,
	  data: URLのクエリ（パラメータ）,
	}).done(function(data, textStatus, jqXHR){
	  // 成功の場合の処理
	}).fail(function(jqXHR, textStatus, errorThrown){
	  // エラーの場合処理
	});
[ajax()：ajaxメソッド(成功はdone、失敗はfail)による非同期通信](http://karashidaimyojin.com/jquery/ajax-ajax/)

## エレメントとは
- HTML や XML 文書における、要素（タグ）
- ブラウザ画面上に配置して表示できる、DOM オブジェクト

### タグ（要素）はエレメントとなる

	<span>あいうえお</span>
	<div>かきくけこ</div>
	<img src="http://example.com/test.jpg">


### エレメントは、アトリビュート（属性）を管理することができます。
> - 以下のidやwidth,height,srcのこと

	<span id="aaa">あいうえお</span>
	<div width="300" height="200">かきくけこ</div>
	<img src="http://example.com/test.jpg">

### インラインスタイルについて
- エレメントは、スタイル属性（インラインスタイル）を保有。
- スタイル属性を使用すると、エレメントごとに、個別にスタイルを設定することができます。
	<div style="color: #f22; background-color: #fcc; width: 400px; height: 300px;">
		あいうえお
	</div>
- [スタイルについて](https://hakuhin.jp/js/style_declaration.html)

### document.createElement('tr');

  // 新しい div 要素を作成します 
  var newDiv = document.createElement("div"); 
  // いくつかの内容を与えます 
  var newContent = document.createTextNode("Hi there and greetings!"); 
  // テキストノードを新規作成した div に追加します
  newDiv.appendChild(newContent);  




# 2019/10/04
## 自習


### 本日行ったpaizaの問題
- D136:空港の呼称
- D135:【キャンペーン問題】多角形の調査
- D134:タイトルの長さ
- D120:鉛筆の数
- D010:Eメールアドレス
- D081:【キャンペーン問題】家族で分ける

	
>nextLine( )メソッドは空白(スペース)を含む文字列を取得することができます。  
一方next( )メソッドは空白までの文字列を取得します。

資金X円
上昇前A円
上昇後B円

int X
 ((X/A)* B - (X/A) * A)
 



### substring

int num = 1234567

num.substring(x,y)
x+1番目の文字列から
y番目の文字まで切り出す

num.substring(1,4)



# 2019/10/02
## 自習
### 復習
#### 本知識  
1. メソッドの引数が同じ型の場合可変長引数が使える

	String method (String a , int .....math){
	//.....が渡せる引数の数
	}

2. Javadoc
HTMLでのドキュメントとしてかける。

	/**
	*「ここにかく」
	*/

#### 015-Javaの基本-配列のネスト
実行すると
90  
70  
になる。  
[][]の一つ目の[]は三つある{}のどれかを指し示し、二つ目は{}内で
何番目かをさす。  

	    public static void main(String[] args) {
	        int score[][] = {{ 100, 80, 90, 90 },
	                            { 90, 90, 90, 90 },
	                            { 60, 90, 80, 70 } };
	        System.out.println(score[0][3]);
	        System.out.println(score[2][3]);
	    }

#### .lengthについて
配列名.lengthで配列の要素数を取得する。

	int n[] = {18, 29, 36, 12};
	System.out.println(n.length);
#### 多次元配列の場合、  
①以下の場合  
2  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num.length);

②以下の場合  
3  
3  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num[0].length);
	System.out.println(num[1].length);

さらに配列のネストが深くなるとnum[i][j].lengthになる？
	
#### newについて
newがインスタンスの生成時にクラス名 オブジェクト名= new クラス名()で使用することは理解しているが、 

	ABC abc = new ABC();

配列の宣言時にも使用することができる。

	int abc[];	//またはint[] abc;
	abc = new int[5]

配列の宣言とインスタンスの生成に同じnewを使う理由がよくわからんので調べた。

[Let's プログラミング](https://www.javadrive.jp/start/array/index2.html)
>変数の場合は宣言するだけで一つの値を格納できる場所が確保されましたが、  
配列の場合では値を格納する場所を必要な数だけ後から確保する必要があります。  
場所を確保するにはnew演算子を使って次のように行います。  

宣言ではなく値を格納する場所を確保しているらしい。


[働いたら負け](http://mikado.hatenablog.jp/entry/2014/06/07/170407)
>”new”が何を表すのか一言で言うとメモリ内に変数（コンストラクタ）を
扱うための領域（オブジェクト領域）を作成します。
	String array = new String[3];
変数の宣言でarrayを扱う領域が確保される。
newString[3]で実データを扱うための領域を新たにメモリ内に確保。
確保した領域の場所をarrayに代入して、arrayが配列として使える。


[Javaでインスタンスを使う方法【初心者向け】](https://techacademy.jp/magazine/17543)

	PersonalInfo p1 = new PersonalInfo();
newをすることでメモリ内にPersonalInfoクラスと同じ構造の領域を確保され、
その領域をp1と呼ぶ。

- 結論：newはメモリの領域を確保する


#### 016-Javaの基本-配列のネストとfor文


	public class ExampleArrayNestFor {
	    public static void main(String[] args) {
	         int score[][] = { { 100, 80, 90, 90 },
	                             { 90, 90, 90, 90 },
	                             { 60, 90, 80, 70 } };
	         String label[] = { "Tom", "John", "Mary" };
	         for (int i = 0; i < score.length; i++) {
	              System.out.print(label[i] + "'s score:");
	              for (int j = 0; j < score[i].length; j++) {
	                   System.out.print(score[i][j] + " ");
	              }
	              System.out.println();
	         }
	    }
	}

	
#### 017-Javaの基本-mainメソッドの引数

メインメソッドに引数を指定して渡すことができる。

	public static void main(String[] args){
	}
mainメソッドはString型配列の変数argsを引数として受け取る。
javaファイルを呼び出す際に値を入力することで
argsとしてうけとれる。

	java クラスファイル名 値1 値2 ..
コマンドプロンプトで以下の文を入力
	java クラスファイル名 値1 値2 
	
二つの値を記載して入力すると合計した値が計算される。


	public class MainMethodArgument {
	     public static void main(String[] args) {
	          if (args.length != 2) {
	               System.out.println("Please set two arguments.");
	               System.exit(0);
	          }
	          int data1 = Integer.parseInt(args[0]);
	          int data2 = Integer.parseInt(args[1]);
	          System.out.println(data1 + data2);
	     }
	}
#### 025-オブジェクト指向の基本-メソッドのオーバーロード
- 同じメソッド名でも引数を変えることで別の記載を使用することができる。


	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product();
	          System.out.println(product1.getPrice());
	          Product product2 = new Product();
	          System.out.println(product2.getPrice(10));
	     }
	}


	class Product {
	     private int price = 10000;

	     public int getPrice() {
	          return this.price;
	     }

	     public int getPrice(double rate) {
	          return (int) (this.price * (100 - rate) / 100);
	     }
	}
#### 028-オブジェクト指向の基本-クラス変数とクラスメソッド


public class BasicClass {
     public static void main(String[] args) {
          Product product1 = new Product("pencil", 100);
          Product product2 = new Product("eraser", 60);
          System.out.println(Product.getProductCount());
     }
}

class Product {
     private String productName;
     private int price;
     private static int count = 0;

     public Product(String productName, int price) {
          this.productName = productName;
          this.price = price;
          count++;
     }

     public static int getProductCount() {
          return count;
     }
}

# 2019/10/01
## 自習

	package main;

	import java.util.Timer;
	import java.util.TimerTask;

	public class SampleTimer{

		public class SampleTimer{

			public static void main(String[] args){
				System.out.println("タスクを3秒後に実行されるようにセットしました。");
				//ここの記載方法が不明！！なによこのかきかた
				TimerTask task = new TimerTask(){
					public void run(){
						System.out.println("タスクが実行されました");
					}
				};

				Timer timer = new Timer();
				timer.schedule(task,3000);
			}
	
## アサートの失敗
システムパスの信号線において、それが有効な状態にあることをアサートという  
無効な状態にあることをネゲートという  

何故そんな言葉があるのか、それは以下の理由による。  
信号線が有効(オン)になった状態と無効(オフ)になった状態を実際の  
電気回路で実現する場合、  
1. 電圧レベルの高い状態をオン、低い状態をオフ  
1. 電圧レベルの低い状態をオン、高い状態をオフ  
上記の二通りがある。 
実際の電圧レベルの信号の状態で言い表すことは  
ややこしくなってしまうので、有効か無効かを表す言葉がある  

# 2019/09/20
## 自習
### java復習
復習cast
変換が微妙なので再度復習

	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = i / j;

		System.out.println("result = " + result)
この場合実行すると  
result = 3.0になる  
resultの型がfloatなので3.3333になりそうだが、  
計算している変数がともにintのため、計算結果もint型になり切り捨てられる。  
小数点以下を計算したいのであれば変数i,jをfloat型で宣言する。  
  
キャスト変換を利用するのであれば  
	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = (float)i /(float) j;

		System.out.println("result = " + result)
上記のようになる。(型)を変数名の前に着ける。  






for文は覚えている？  
for( i = 0 ; i<10 ; i++){

}
拡張for文は？
拡張for文とは配列のためのfor文。
以下のようになる
	for(データ型 変数名:配列名){
	}
	
	String [] names = ("John", "Kate" , "Bob"};
	for(String name : names){
		System.out.println(name);
	}

配列namesに入っている要素すべてを出力する
	
	通常のfor文で書くとすると
	
	String [] names = ("John", "Kate" , "Bob"};
	for(int i = 0; i<3;i++){
		System.out.println(names[i]
	}
	//自分でかけたぜ！



# 2019/09/20
## 自習
### java配列
	型[] 変数名 = {};

	int[] numbers = { 5,13,29};
	String[] names ={"John","Kate","Bob"};

配列の要素には前から順に「0,1,2」と番号が割り振られている

これをインデックス番号と呼ぶ。  

配列の各要素は配列名[インデックス番号]とすることで取得できる。  
	System.out.println(numbers[1]);

### 配列とfor文

配列namesの要素を全て出力するために、以下のようにいちいち全て書くのは非効率。
	①	String[] names ={"John","Kate","Bob"};
		System.out.println("Hello" + names[0]);
		System.out.println("Hello" + names[1]);
		System.out.println("Hello" + names[2]);

これを短く変更すると②になる  
	②	String[] names ={"John","Kate","Bob"};
		for(int i=0; i < 3;i++){
			System.out.println("Hello" + names[i]);
		}  
拡張性を増やすならば？要素数が増えても対応できるようにしよう。  
	③	String[] names ={"John","Kate","Bob"};
		for(int i=0; i< names.length;i++){
			System.out.println("Hello" + names[i]);
		}
# 2019/09/18
## 自習

### 課題
ボーナス額の計算
//月給*ボーナス
//Scannerは「a b」の入力があった場合、1度のnext()の呼び出しで
//空白までを受け取る。よって今回の場合、1度目の呼び出しで「a」を
//2度目の呼び出しで「b」  

	import java.util.*;


	public class Main {
	    public static void main(String[] args) {！

	        Scanner sc = new Scanner(System.in);
	        int num1 = sc.nextInt();
	        int num2 = sc.nextInt();
	        
	        System.out.println(num1 * num2);
	    }
	}
### 桁計算
	package java0910;

	public class Main {
	    public static void main(String[] args) {

	/*     
		//入力値の桁を出力するプログラム
		//書いたけどだめだったやつ
		System.out.println("計算を行います");
		int a= 10000;
		int n =0;
		int keta =0;
		for(keta=a; keta<1; n ++){
		 keta=    keta/10;
		}
		System.out.print("出力結果：");
		System.out.println(n);
	*/
		//正解
		int val =100;
		int valen = String.valueOf( val).length();
		System.out.println(valen);
	}


	}
# 2019/09/17
## 自習

https://www.saycon.co.jp/touchtype/
https://www.techscore.com/tech/DesignPattern/Iterator/Iterator1.html/

## 写経
	1.1		Itaratorパターン
	繰り返す=Itarator
集約オブジェクト 
「Listクラス」
	要素としていくつかのオブジェクトを持つことができるものとする。
	このListオブジェクトが持つ要素に順番にアクセスするような場合、どのような順番で
	各要素にアクセスするのかによってさまざまな走査方法が考えられる。
	①何らかのパラメータを利用して走査
	②各オブジェクトの名前の順
	この「走査方法」はだれが提供するのか。
	Listクラスですべて提供するのは不可能。
	酔って走査方法を提供するクラスを独立させる。
	
	必要な操作方法を与えるクラスを自分で作成すし、利用することで
	柔軟な設計となる。
	
	また集約オブジェクトとして利用するクラスを変更する必要が生じた際、
	その変更が多くの部分に影響を与えるようなことが考えられる
	
	public class Student{
		private String name;
		private int sex: //男の子:1 女の子:2
		
		public Student(String name.int sex){
			this.name = name;
			this.sex = sex;
		}
		public String getName(){
			return name;
		}
		public int getSex(){
			return sex;
		}
	
生徒は名前、性別を表すメンバ変数name、sexを持ち、名前を返すgetName()メソッドと
性別を返すgetSex()メソッドを持ちます。これらの生徒を管理するために学校から先生に
名簿が支給されます。学校から与えられる名簿は以下のように記述されています。


