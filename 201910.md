# 2019/10/28
## 自習
### 2. スレッドの実行
	マルチスレッドプログラミング2章 スレッドの実行
	- 2.1. Threadクラスを継承する方法
	- 2.2. Runnableインターフェースを実装する方法
	- 2.3. 2つのスレッド作成方法の比較
プログラムの中でスレッドを作成する方法は二つある。
ひとつはjava.lang.Threadクラスを継承したクラスを作成する方法。
もう一つはjava.lang.Runnableインターフェースを実装したクラスを
作成する方法。
#### 2.1. Threadクラスを継承する方法

Threadクラスを継承したクラスを利用して新しいスレッドを実行するには。
	1. Threadクラスを継承するクラスを作成する。
	2. そのクラスでrunメソッドを宣言する。
	3. そのクラスのインスタンスを作成する。
	4. そのクラスのstartメソッドを呼び出す。

以下、3から0まで数字をカウントダウンする処理を2つのスレッドをで
同時に実行するプログラム。

	class CountDownThread extends Thread {
		private String name ;
		
		public CountDownThread(String name) {
			this.name = name;
		}
		
		public void run() {
			for (int i = 3; i >= 0; i--){
				try {
					sleep(1000);
				} catch(InterruptedException e) {}
				System.out.println(name + "：" + i);
			}
		}
		
		public static void main(String[] args) {
			CountDownThread t1 = new CountDownTrehad("thread 1");
			CountDownThread t2 = new CountDownThread("thread 2");
			t1.start();
			t2.start();
		}
	}


1行目のクラス宣言を見ると、このクラスがTreadクラスを継承していることが分かる

runメソッドには新しいスレッドで実行させたい処理を記述する。
ここではforループを用いてカウントダウン処理を行っている。
なお、runメソッド内で使用しているsleepメソッドは、Threadクラスの
staticメソッドsleepメソッドは現在実行中のスレッドを指定した時間だけ
休止させる機能をもつ。ここでは1回カウントするたびに1000ミリ秒待つように
指定している。

スレッドを利用するためにはスレッドのインスタンスを作成する。
	CountDownThread t1 = new CountDownThread("thread 1");
	CountDownThread t2 = new CountDownThread("thread 2");
	
最後にstartメソッドを呼び出すことでスレッドを起動している。
ここで、runメソッドではなく、startメソッドを呼んでいることに注意。
runメソッドを呼んでもrunメソッドに記述した処理は実行されるが、
通常のメソッド呼び出しと同じで、新しいスレッドは起動されない。
startメソッドを呼び出すことで、新しいスレッドが起動され、その
新しいスレッドによってrunメソッドが実行される。

例外について「InterruptedException」は割り込みが発生した場合に
投げられる例外。J2SEに含まれるクラスの一つ。パッケージも含めたクラス名は
java.lang.InterruptedException。Treadクラスのsleepメソッドなどの
一時的にスレッドを





#### リスト

List<型名> オブジェクト名 = new ArrayList<データ型名>();
List型のオブジェクトにはArrayListクラスで生成したインスタンスを格納する。
インスタンスを生成するときはnew演算子を用いる。

例えばString型の要素を持つListの場合には
List<String> list = new ArrayList<String>();


#### List内のデータをfor文で処理する方法①

	List<Integer> list = new ArrayList<Integer>();
	
	list.add(1);
	list.add(2);
	list.add(3);
	list.add(4);
	
	for( int i = 0; i < list.size(); i++){
		Integer value = list.get(i);
	}


上記の処理では「list.size();」による負担が重いので以下の変更

	List<Integer> list = new ArrayList<Integer>();
	
	list.add(1);
	list.add(2);
	list.add(3);
	list.add(4);
	int size = list.size();
	
	for( int i = 0; size; i++){
		Integer value =list.get(i);
	}

サイズを変数に入れて使用する場合、要素数を削除するときに問題が発生する。

	int size = list.size();
	for(int i = 0; i < size ; i++ ) {
		Integer value = list.get(i);
		list.remove(i);
	}


//配列の要素を削除するremoveメソッドはリスト内の指定された位置から
//要素を削除する。そして、皇族の要素を左側に移動し、それぞれのインデックス
//から1を減算する。
このコードでは、listのサイズが変更されても変数sizeの値は変わっていないため
実際の要素数を越える場所にアクセスしようとして例外が発生する。
そのため対応すると
	int size = list.size();
	for(int i = 0; i < size; i++){
		Integer value = list.get(i);
		list.remove(i);
		size = list.size();
	}

これでは処理を軽くするために変数を用意した意味がない。
それに対応できるのが「iterator」

#### iterator
iteratorとは配列の要素番号や要素数を気にせずループ処理を行うための機能。
iteratorを使うことで削除といった書くよう素数に対して要素番号を直接
指定する必要がない。

	List<Integer> list = new ArrayList<Integer>();

	list.add(1);
	list.add(2);
	list.add(3);
	list.add(4);

	Integer it = list.iterator();

	while(it.hasNext()){
		Integer value = (Integer)it.next();
	}


hasNextメソッドでは次に要素数がある場合はループ処理を繰り返す。
そして、nextメソッドを呼び出すとイテレータを次の要素に進めると同時に
次の要素を返す。




### 2. Adapterパターン1
Teacherクラス
Taroクラス

ChairPersonクラス
	メソッドの実装のみ
Newtaroクラス
	
Taroクラスを継承。
CairPersonインターフェースを実装

//インターフェイスは、クラスのような「具体的な実装」を提供するものではなく、あくまでも「仕様」や「規約」、「契約」として//の役割を提供するためのもの
//クラスの継承は既に実装された機能を再利用するための仕組みであるのに対して
//インターフェースはライブラリの「設計」における決まりごとを定めるために重要ということ。

NewtaroはTaroを継承して既存の機能であるenjoyWithClassmateを利用する。
利用する方法としてはChairPersonのorganizeClass()を利用した。


Taroが継承しない場合


### 委譲

	package test1;
	
	public class Color1 {
		public void method1() {
			System.out.println("赤です");
		}
	}


	package test1;
	
	public class Color2 {
		Color1 c = new Color1();
		public void method1(){
			c.method1();
		}
	}


	package test1;
	
	public class Test1{
		

#### Adapterパターン まとめ
利用したいインターフェースを変えたいような場合に利用する。
継承と委譲の二つがある。

### 3. TemplateMethodパターン
#### 3.1 TemplateMethodパターンとは

TanakaWoodCutPrint クラスのインスタンスのcreateWoodCutPrintメソッドを
呼び出せば、TanakasWoodCutPrintクラスで用意されているdraw,cut,printの
各メソッドが呼び出されます。
TemplateMethodパターンを利用することで、クラスの全員が間違いなく
木版画を作成することができます。もし処理の流れをテンプレートにせず、
SomeonesWoodCutPrintクラスの中に記述していたらバラバラになる。


### 文字列の中に文字列があるか探す方法
	import org.apache.commons.lang3.StringUtils;
	StringUtils.indexOf(weathre, "S");
### 文字列の中に文字があるかを探す方法
	


## D問題
- お月見団子
- D068:雨と晴れの記録
- D023:Aの個数
- D131:脱出ゲーム
- D075:足りないカード
- D132:N回ゲーム
- D089:数字の取得


### 正規表現の使い方

#### matchesメソッドでチェックする方法

はじめに正規表現で指定したパターンと一致するかを確認する簡単な方法として、
Stringクラスのmatchesメソッドの使い方を解説します。
matchesメソッドは指定した文字列と正規表現が完全に一致した場合に
"true"を返します。一部が一致しただけでは"false"を返すので注意。

Stringクラスのmatchesメソッドの使い方を次のプログラムで確認してみましょう


	public class Main {
		public static void main(String[] args) {
		
      // 検索する文字列を用意
        String str = "東京都千代田区 123-4567";
        
        System.out.println(str.matches(".*[0-9]{3}-[0-9]{4}.*"));
        System.out.println(str.matches("[0-9]{3}-[0-9]{4}"));
        
        System.out.println(str.matches(".*123-4567.*"));
        System.out.println(str.matches("123-4567"));
      	}
     }
     
     
このプログラムではmatchesメソッドを使って、正規表現で表現した文字列が
含まれているかを判定している。matchesメソッドは完全一致のときに
trueを返すので、検索したい文字列の前後に他の文字があるとfalseを返す。

そのため、正規表現のパターンの前後に「任意の文字がいくつかある」という
意味の「.*」を追加して完全一致させることで　"true"を返している。


このプログラムでは、文字列「東京都千代田区123-4567」と正規表現のパターン
「[0-9]{3}-[0-9]{4}」のMatcherオブジェトを作成しています。



#### 文字列から数値のみ出力する記述
        // 正規表現のパターンを作成
        Pattern p = Pattern.compile("[0-9]+");
        Matcher m = p.matcher(str);

        // 出力
        while (m.find()) {
            System.out.println(m.group());
        }

#### 正規表現のパターンオブジェクトを作成する。

	Pattern p = Pattern.compile("[0-9]{3}-[0-9]{4}");
	Matcher m = p.matcher(str);

### 正規表現の特徴

- compile(),とmatcher()を利用して正規表現のパターンを作成する。
- 作成したパターンを利用してチェックを行う。



#### 一致する一致する複数の文字をすべて抽出する方法

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {
	public static void main(String[] args) {
		
		// 検索する文字列を用意
		String str = "東京都千代田区 123-4567, 東京都渋谷区 111-2233";
		
		//正規表現のパターンを作成
		Pattern p = Pattern.compile("[0-9]{3}-[0-9]{4}");
		Matcher m = p.matcher(str);
		
		while (m.find()) {
			System.out.println("一致した部分は : " + m.group());
		}
	}
}

findメソッドは一致した場合に"true"を返すので、while文のループで一致する
文字列がなくなるまで検索と表示を繰り返す。

継承と実装について講義


javaにおいてinterfaceとは


interface A { 
	void doSomething();
}


class X implements A {
	public void doSomething() {
		System.out.println("X");
	}
}


class Y implements A {
	public void doSomething(){
		System.out.println(Y);
	}
}


この例では、Aインターフェースが「規約」であり、Aという型のオブジェクトは
「void doSomething()をする」という決まりごとだけが定義されている。
そしてクラスX,クラスYはともにAインターフェースを実装しており、
すなわちXとYはAで定められた規約の具体的なHowを提供する。

これらのコンポーネントを利用する側のクラスとしては

		public class Z {
			public void method(A obj) {
				obj.doSomething();
			}
		}

このZクラスのmethodを呼び出す場合、引数で定義されているA型であれば、
どのようなオブジェクトでも渡すことができる。A型の契約を締結している
オブジェクトはdoSomethingメソッドを提供していることが保障されているから。
どんなオブジェクトを渡されようとも(XでもYでもOK)それがA型という規約を
守っているのであれば、そのオブジェクトのdoSomethingメソッドを呼び出して
正常に処理することができるという保障が生まれる。

逆にA型を実装していない、Aという契約を締結していないほかのオブジェクトを
渡すことができない。それはdoSomethingメソッドが実装されている保証がないから。

このようにインターフェースはオブジェクトと別のオブジェクト間の
仕事の依頼に関する決まりごとをコードとして明示するためのもの。

クラスの継承は既に実装された機能を再利用するための仕組みであるのに対して
インターフェースはライブラリの「設計」における決まりごとを定めるために重要ということ。







# 2019/10/18
## 自習
### 未だにわからない
- 070-コレクションフレームワーク-メソッド参照とラムダ式を使ったサンプル
- 071-コレクションフレームワーク-HashMap
- 写経タッチタイピングゲームの後半あたりを理解したら仕事できるようになりそう

### 注意
- 「または」は「or」ではなく「||」
- 新しい変数名に「○○2」と最後に数字をつけると既存の別変数「○○」を「○○1」とタイプミス
- 配列の宣言の仕方
- 配列の項目番号の指定を忘れる
- 一つのメソッドで行おうとしてしまう
- 型を修正したときに影響範囲を忘れる
- 変数の初期化、宣言の範囲
- 既に宣言した配列の型を宣言する
- 「=」と「==」を間違える
- 出力値を間違える

### 問題
- 今日:10
- D118:こよみの変換
- D013:割り算
- D045:通知票
- D057:プレゼント選び
- D021:文字列の一致
- D015:カウントダウン
- D121:AからRへ
- D097:梅雨入りの予想
- D011:アルファベットで何番目
- D039:正三角形かどうか
- D101:偶数派と奇数派

- 63/132 残り70

### D101:偶数派と奇数派
偶数派と奇数派
偶数-偶数-NO
偶数-奇数-YES
奇数-偶数-YES
奇数-奇数-NO

二つの値の和が奇数になればいい。

### 問題C-2
- C019:完全数とほぼ完全数
- 割り切れなくなるまで割る。
	- 約数が全て出る。
	- 出ない。
- その数字自身を除いた約数を合計したものが完全数
- 約数とはその数字を割り切れる値。
	- 1からその数字の半分で割り切れるものを出力して合計する。
#### 消すやつ

	import java.util.*;


	public class Main {
	    public static void main(String[] args) {

	        Scanner sc = new Scanner(System.in);
	        int num = sc.nextInt();
	        int[] value = new int[num];

	        for( int i = 0; i < num; i++){
	            value[i] = sc.nextInt();
	            //System.out.println(value[i]);
	            int value2 = 0;
	/*            while(value[i]>1){
	                value[i] = value[i]/2;
	                System.out.println(value[i]);
	                value2 = value2 + value[i]; 
	            }
	            */
	            for( int j = 1; j <= value[i]/2; j++){
	                if(value[i] % j == 0){
	                    value2 = value2 + j;
	                }
	            }
	            if(value[i] == value2){
	                System.out.println("perfect");
	            }else if(value[i] == (value2 - 1) || value[i] == (value2 + 1) ){
	                System.out.println("nearly");
	            }else {
	                System.out.println("neither");
	            }
	        }
	        
	    }
	}
#### 自作コード修正②
	import java.util.*;
		public class Main {
		    public static void main(String[] args) {

		        Scanner sc = new Scanner(System.in);
		        int num = sc.nextInt();
		        int[] value = new int[num];

		        for( int i = 0; i < num; i++){
		            value[i] = sc.nextInt();

		            if(value[i] == isPerfectNumber(value[i])){
		                System.out.println("perfect");
		            }else if(value[i] == (isPerfectNumber(value[i]) - 1) || value[i] == (isPerfectNumber(value[i]) + 1) ){
		                System.out.println("nearly");
		            }else {
		                System.out.println("neither");
		            }
		        }
		    }
		    public static int isPerfectNumber(int val){
	            int value2 = 0;
	            for( int j = 1; j <= (val / 2); j++){
	                if(val % j == 0){
	                    value2 = value2 + j;
	                }
	            }
	        return value2;
		    }
		}
		
# 2019/10/17
## 自習
### paiza
現在23
- D031:分から秒へ 
- D033:頭文字 
- D008:奇数か偶数か 
- D065:エラーコードの分類
- D115:【エンジニア死滅コラボ問題】おかしの二等分 
- D042:行列
- D027:nまでの和
- D099:短冊づくり
- D111:文字を切り詰める
- D106:割った余り
- D016:N文字目まで出力
- D052:ピラミッドの作り方
- D112:工場の生産力
- D022:表面積の計算
- D110:3つの数字
- D126:点数の計算
- D067:スイッチのオンオフ
- D041:本棚選び
- D091:花粉の予報
- D036:アットマーク
- D105:長さの一致
- D103:逆さ読み★
- D043:天気の表示
- D032:充電時間 
- 51/132残り81

### HashMap
[絶対に分かるハッシュマップ](https://qiita.com/ztrehagem/items/32407b3bae8fb92d4baf)
### listとArraylistの違い
[listとArraylistの違い](https://www.sejuku.net/blog/14886)

#### Listとはインターフェースと呼ばれる中小メソッドのみを持ったクラス的なやつ。
単体では使えないので実装する必要がある。インターフェースを実装することで
実装したクラスを使うことができるようになる。

#### ArrayListとは
ArrayListとはlistインターフェースを実装したコレクションクラス

#### 宣言の型はListとArrayListのどちらを使うべきか

##### Listはインターフェースなのでインスタンスの生成ができない

	×List<Integer> list = new List<Integer>();

	○List<Integer> list = new Array<Integer>();

##### ArrayListはListの実装クラスなので以下ができる。

	○ArrayList<Integer> list = new ArrayList<Integer>();
	
##### ではどちらを使うべきか
- 宣言：List,生成：ArrayList
> メリット：ArrayListからLinkedList等別のコレクション(データ型)に変更したい場合宣言時のListには手を加えなくても良い
> デメリット：ArrayListにしかないメソッドを使いたい場合、宣言はListであるため型キャストが必要

### ラムダ式について
#### 基本書式
	(メソッドの引数列) -> {処理内容}

#### 例1
	(int x, int y) -> {return x + y;}

#### 引数の型宣言を省略
	(x,y) -> {return x + y;}
	
#### 1行の記述ですむ場合、「{}」を省略できる
	(x,y) -> return x + y;





### 線形探索(リニアサーチ）
- 先頭から順番に探す値が見つかるまで探していく。
- 配列を直線的(リニア)に探すのでリニアサーチ
#### 目的：配列からある値を探すこと
#### 現状：分かっているのはデータの「個数」「それぞれの値」、「探す値」
#### 結果：「値があるか」「どこにあるか」
#### メリット：単純で実装しやすい
#### デメリット：処理速度が遅い。
#### 内容
- 特徴：探す値が見つかったときはそのデータの「配列番号」は必ず「0以上の整数」
1. 探す値が見つかったときは配列の番号0以上の整数を使う
2. 探す値が見つからなかったときはマイナスの値を使う
#### サンプルソース

	package argo;

	public class ArgoLinearSearch {

	    public static void main(String[] args) {
	        int[] data = {30, 60, 70, 90, 20} ;
	        System.out.println(search(data,70));
	    }
	    public static int search(int[] data , int target){
	        int find = -1;
	        for(int i = 0 ; i < data.length; i++){
	            if(data[i] == target){
	                find = i + 1;
	            }
	        }
	        return find;
	    }

	}

### 二分探索
#### 目的：配列からある値を探すこと
#### 現状：分かっているのはデータの「個数」「それぞれの値」「それぞれの値がソートされている」、「探す値」
#### 結果：「値があるか」「どこにあるか」
#### メリット：処理速度が速い。
#### デメリット：処理が複雑
#### 内容
- data.length == 12;
##### 1回目 
right == 12-1;
mid == 0 + 11 /2 = 5.5 //int型のため切捨て5
if(data[i]==target)の場合
	mid+1が戻り値
else if (target < data[mid])の場合
	right = mid;//探索範囲の右端が真ん中になる
else(target > data[mid])の場合
	left = mid+1//探索範囲の左端が真ん中になる
	
##### 2回目
right == 11
left == mid + 1 //mid==5なのでleft==6

mid == 11+ 6 = 17 //8
target = 140 ;
data[8] = 170;

right = 8



#### サンプルソース
	public class ArgoBinarySearch {
	    public static void main(String[] args){
	        int[] data = {10, 30, 40, 60, 80, 90, 110, 140, 170, 190, 210, 260};
	        System.out.println(search(data,140));
	    }
	    public static int search(int[] data, int target){
	        int find = -1;
	        int left = 0;
	        int right = data.length-1;
	        while(left < right){
	            int mid = (left + right) / 2 ;
	            if(data[mid] == target){
	                return mid + 1;
	            }else if(data[mid] < target) {
	                left = mid + 1;
	            }else {
	                right = mid;
	            }
	        }
	        return find;
	    }
	}
#### 疑問点
- 最後のright = mid;が分からない
- right = mid -1;では何故だめなのか
- data[mid] ==targetの余地をなくしてしまうから？

#### 帰ったら削除
	import java.util.*;


	public class Main {
	    public static void main(String[] args) {

	        Scanner sc = new Scanner(System.in);
	        String line = sc.next();
	        String line2 ="";
	        int num = line.length();
	        for(int i = 0; i < line.length(); i++){
	            line2 =line2.concat(line.substring(num-1,num));
	            num = num-1;
	        }
	        System.out.println(line2);
	    }
	}



# 2019/10/16
## 自習

### super
- 親クラスの引数を持つコンストラクタを呼び出すには、super という命令を使用した
- 以下を追加するとよいかもしれない
-  * @param 
-  * @return
### いろんなメソッド
- 「変数.equals(変数2)」で変数1と変数2の文字列の比較ができる。
	- 文字列であるString型は[別の変数-中身同じ]といったときに変数自体を比較してしまうので「==」はだめ。
	



### jarファイル


- jarファイルとはjarファイルは他のプログラムで使うライブラリや
- Javaアプリの実行ファイルとして使えるので、流用ができて便利です。
jarとは、コンパイルされた複数のclassファイルおよび
それが使用する画像などのリソースを一つにまとめZIP形式で圧縮されたファイル、
もしくはそれを出力するツールのことを言います。Java Archiveの略です。
- jarファイルは実行可能な形式ではない。
- 私のようなプログラミング初学者にとって「アプリケーションを実行する」とは以下である。
	1. アイコンをダブルクリック
	2. 機能が実行される
- しかしjavaの成果物はその段階まで行かず、コマンドラインから実行する必要がある。
- 私が作る場合はその段階まで行いたいので「.exe」形式に変換する。


### 入力した値の数だけ日付を出す
	import java.util.Calendar;
	import java.util.Date;
	import java.util.Scanner;

	public class Calendar1 {
	    public static void main(String[] args){
	        Scanner scan = new Scanner(System.in);
	        int a = scan.nextInt(); 
	        for(int i = 0; i < a; i++){
	            Calendar cal = Calendar.getInstance();
	            cal.add(Calendar.DAY_OF_MONTH, i);
	            Date date = cal.getTime();
	            System.out.println(date);
	        }
	        
	        scan.close();
	    }
	}









### Stringからintに型変換
	public class ExampleString4 {
	    public static void main(String[] args){
	        String inputStr = "10000";
	        //intではなくinteger.parseIntで型変換する
	        //
	        int data = Integer.parseInt(inputStr);
	        System.out.println(data + 500);
	    }
	}



### intからStringに型変換


	public class ExampleInt {
		public static void main(String[] args){
			int num = 10000;
			//
			String str = String.valueOf(num);
			System.out.println("str = " + str);
		}
	}
	
### 時刻の比較


	import java.text.DateFormat;
	import java.text.ParseException;
	import java.text.SimpleDateFormat;
	import java.util.Calendar;
	import java.util.Date;

	public class ExampleDateOld {
	 public static void main(String[] args) {
	      System.out.println(compareDate("2020/01/01"));
	 }

	 public static int compareDate(String date) {
	     
	/*     Calendarクラスはabstractクラスのため直接new演算子で
	 *     オブジェクトを作成することはできない。「getInstance」メソッドを
	 *     使うことでオブジェクト作成することができるようになっている。
	 *     このメソッドを使って取得したCalendarクラスのオブジェクトはデフォルトの
	 *     値としてこのメソッドが実行されたときの日時の情報を取得している
	 *     作成されたオブジェクトから日付情報などを取得することができる
	 *     また、「getInstance」メソッドはstaticメソッドのため
	 *     「Calendar.getInstance()」のように利用する。
	*/     
	      Calendar cal = Calendar.getInstance();

	/*      Calendarクラスのsetメソッドはカレンダーの時刻や日付などの
	 *      要素を設定するときに使用する。
	 *      
	 *      また、Calendarクラスで用意されている定数を指定して、
	 *      年、月、日などの単位ごとまたはまとめて取得することができる
	 *      >HOUR_OF_DAY    時間を24時間単位で表します。
	 *      >MINUTE 分を表します。
	 *      >SECOND 秒を表します。
	 *      >MILLISECOND ミリ秒を表す。
	 *      時間、分、秒、ミリ秒に0をセットしている。
	*/
	      cal.set(Calendar.HOUR_OF_DAY, 0);
	      cal.set(Calendar.MINUTE, 0);
	      cal.set(Calendar.SECOND, 0);
	      cal.set(Calendar.MILLISECOND, 0);
	/*
	 *      CalendarクラスでのgetTime() 
	 *      現在の日時を返す。
	 *      Calendar型からDate型へ変換する場合は、Calendar型の変数に対して、
	 *      getTimeメソッドで現在時刻を取得し、Date型の変数に設定すれば変換できます。
	*/
	      Date currentDate = cal.getTime();
	/*
	 *      DateFormatのサブクラスであるSimpleDateFormatクラスのオブジェクトを生成している。
	 *      子クラスのインスタンスは親クラスの型を持つ変数に代入することができる。
	 *      このときは親クラスの型を持つので子クラスのメソッドを呼び出すことはできないが、
	 *      親クラスのメソッドを呼び出すことができる。
	 *      ただしコンストラクタは生成時に行われるので子クラスのコンストラクタが呼び出されている。
	 *      [継承と型参照](https://java2005.cis.k.hosei.ac.jp/materials/lecture18/polymorphism.html)
	 * 
	 *      @setLenient:日付時刻解析を厳密に行うかどうかを設定する。
	 *      (Lenientとは寛大という意味。「寛大を(false)」)
	 *       例えば2013年に2月29は存在しないが、入力すると、自動的に2013年3月1日と
	 *      判定してくれる。そのときに間違いだと「false」を指摘してくれる記載。
	 *      オブジェクトを生成して、「try{}」の上に書くのが基本。
	 * */
	      DateFormat format = new SimpleDateFormat("yyyy/MM/dd");
	      format.setLenient(false);
	      try {
	/*          parse()　指定された文字列の先頭からテキストを解析して日付を生成します
	 *          引数dateから日付を生成してchekDateに突っ込む
	 *           DateとCalendarの違いとは
	 *           Calendarクラスは、日付や時刻の演算処理を行う機能で、日付の値を細かく計算することができます。
	 *           Dateクラスは、1970年1月1日0時からの経過時間を持ち、主に指定した日付や時間を取得するのに用いられます。
	 *           
	*/
	          Date checkDate = format.parse(date);
	          /*compareToメソッドで日付を比較する場合の戻り値は次の通り
	           * メソッドの呼び出し元の日付が、引数の日付より前の場合は”-1”
	           * メソッドの呼び出し元の日付が、引数の日付より後の場合は”1”
	           * メソッドの呼び出し元の日付が、引数の日付と同じ場合は”0”
	           * return文があるとそこで呼出元に戻り値を返す。
	*/
	           return currentDate.compareTo(checkDate);
	      } catch (ParseException e) {
	           e.printStackTrace();
	      }
	      return -9999;
	 }
	}

### 064:ファイルに文字の入力、ファイルから文字の出力

	import java.io.BufferedReader;
	import java.io.BufferedWriter;
	import java.io.FileReader;
	import java.io.FileWriter;
	import java.io.IOException;

	public class SampleFileIO1 {
	/*  区切り文字について
	 *  windowsでは「\」ではなく「\\」
	*/    
	    public static final String FILE_PATH = "c:\\Users\\80600013\\Desktop\\大西\\01_学習\\01_4_コーディング\\Java\\data.txt";
	    
	         public static void main(String[] args) {
	             /*FileWriterクラスのオブジェクトを作成する場合には
	              * IOExceptionという例外が発生する可能性があるため
	              * 例外の処理をしておく
	              * try()catch(IOException e){)
	              * 
	              * */
	              try {
	                  /*FileWriterについて
	                   * FileWriterクラスは文字を書き込むために使う
	                   * 新しいテキストファイルを作ったり、既に存在する
	                   * テキストファイルに追加で文字を書き込むことができる
	                   * 「FILE_PATH」によってファイルを作成する場所とファイル名を指定
	                   * FileWriterクラスのオブジェクトを作成
	                   * BUrrerdWriterのオブジェクトを作成。
	                   * */
	                   FileWriter fw = new FileWriter(FILE_PATH);
	                   BufferedWriter bw = new BufferedWriter(fw);
	                   /*
	                    * BUrrerdWriterクラスのwriteメソッドを利用して
	                    * ファイルに書き込み
	                    * close()でストリームを閉じる
	                    */
	                   bw.write("Hello, Java!");
	                   bw.close();
	                   /*ここから読込を行っている
	                    * FileReader
	                    * BufferedReader
	                    * */
	                   FileReader fr = new FileReader(FILE_PATH);
	                   BufferedReader br = new BufferedReader(fr);
	                   String data = br.readLine();
	                   br.close();
	                   System.out.println(data);
	              } catch (IOException e) {
	                   e.printStackTrace();
	              }
	         }
	}



### アクセス修飾子
[アクセス修飾子について](https://www.sejuku.net/blog/22679)
| アクセス修飾子 | 同一クラス | 同一パッケージ |サブクラス| 全て|
| -------- |:-------:| -------:|
| public | ○ | ○ | ○ | ○ |
| protected | ○ | ○ | ○ | × |
| 指定なし | ○ | ○ | × | × |
| private | ○ | × | × | × |

### 小数点計算を行った後(型がおそらくdouble)になっているので(int)に戻す
	     private static final double TAX = 0.08;
	     public int getTotalPrice(int price) {
	          return (int) (price * (1 + TAX));
	     }
### 引数の型、数が異なり、同じ名前のメソッド名→オーバーロード
### 「static」がつくクラス変数は大抵、インスタンスの生成を何回やったのかをカウントしてる
	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product("pencil", 100);
	          Product product2 = new Product("eraser", 60);
	          System.out.println(Product.getProductCount());
	     }
	}
	
	class Product {
	     private String productName;
	     private int price;
	     private static int count = 0;
	
	     public Product(String productName, int price) {
	          this.productName = productName;
	          this.price = price;
	          count++;
	     }
	
	     public static int getProductCount() {
	          return count;
	     }
	}

### 032-アルゴリズム-最大値を求める
	public class ArgoMax {
		public static void main(String [] args){
			int[] data = { 30, 60, 70, 90, 20 };
			System.out.print(max(data));
		}
		public int max(int[] data){
			int max = data[0];
			for( i = 1 ; i < data.length ; i++){
				if( max < data[i]){
					max = data[i]
				}
			return max;
			}	

# 2019/10/11
## 自習
### C070:【キャンペーン問題】簡易カードゲームできなかった

package java0905;

	import java.util.*;

	public class Sam {
	    public static void main(String[] args) {
		// 自分の得意な言語で
		// Let's チャレンジ！！

		Scanner sc = new Scanner(System.in);

		String line = sc.next();
		String line2 = sc.next();

		String[] lineArray = new String[line.length()];

		for (int i = 1; i < lineArray.length; i++) {
		    String Rine = String.valueOf(line.charAt(i));
		    lineArray[i] = Rine;
		    System.out.println(lineArray[i]);
		}
	    }
	}

## 映画Pにまつわる彼女との話
今現在Pという新作映画が世界中で大ヒットしているらしい。  
○○賞を取ることが確実だとか、  
主演俳優が何キロダイエットしただとかが、  
俺のニュースキュレーションアプリで表示されている。  
俺も毎日のように記事を読まされていると映画が見たくなり、  
今週末の土日に友人と見に行くことになっている。  


映画はまだ見る前なのでその内容については後日考えるとして  
心が揺さぶられた事件が、この前彼女と二人でいるときに起きたので  
備忘録として残しておく。  


もともとこのPという映画は彼女が紹介してくれたものだった。  
twitterかなんかで調べていて  
「こんな映画あるんだねー」  
「でも暴力的かもしんないし彼女は見れないね」  
「ホラーじゃなきゃいけるよ」とかなんとか。  


5日後くらいに行くことを決めた。理由は下記。  
- 宣伝広告で泣きながら化粧をしている主人公の画が心にきた。  
- 世間から虐げられた主人公の復讐劇は面白い  
- twitterとかニュースで絶賛されていたから
- 「今年一番」「映画史の文脈に刻まれる」みたいなフレーズにやられた


それで俺が心に残った事件は以下の彼女と会話の中で起きた。  
彼女「何でそんなに見たくなったの？」  
俺「映画史の文脈に刻まれる作品っぽいんだよね。これは見とかなくちゃって」  
彼女「その言葉twitterでみたわ(笑)」  
俺「俺も見たかも。ってか(彼女)がみせてくれたやつじゃね？(彼女）が紹介してくれたんじゃね？」  
- この最後の言葉が俺の面白くない部分（平子ってる）。  
- ここで彼女がしたいことは俺の安直なミーハーさを皮肉って笑うこと。


twitterやニュースサイトで書かれているありきたりな
映画評論を本気で真面目にさも自分で考えたかのように
他人に語っている俺の愚かさを笑いにしようとしたら、
俺が「単なる受売りのつもりで最初から話してましたよ」感を出してしまっている。
しかも話したこと自体は事実に基づいているせいで
可笑しさをつぶし、話した彼女側が変なことを言ってる感に変えた。


この場面で俺が取るべきだった対応は
1. 自分のミーハーさを認めて、相手に伝わる自分なりのミーハーさで返答
	- 「ってtwitterに書いてあった」
	- 「ってメンタリストのDAIGOが言ってた。」
2. 頑なに自分のミーハーさを否定する
	- 「年に1万本映画見てる同じ意見か。凄いね。」
	- 「こないだヴェネチア映画祭で見てそう思ったんだよね。友人の映画監督も同じ風に言っててさ」
3. 図星突かれたと怒る
	- 「俺が自分なりの意見話すことを大事にしてるとかいつも言ってるのに。他人の意見をそのまま自分の意見みたいに話しちゃったことを指摘するんじゃねえ」
4. 矢作風にふざける
	- 「だってtwitterでみたんだもん」「アカデミー賞ってtwitterの誰だか知らない人の評判みてきまるんでしょ？」「来年からtwiデミー賞になるって聞いたし」


この出来事が起きた理由  
「映画史の文脈に刻まれる」みたいなフレーズが俺の心に強く残った。  
この映画を見ていないが、ニュースの評論で書かれている無敵の人問題とこの映画がリンクする  
みたいな話が気に入って、感情を入れて話してしまったこと。  
強く共感したときは自分の意見と他人の意見が自分の中で曖昧になること。  

結論：強く共感しても人の意見を感情をこめて話す際には、受け売りだよ。ってことを最初に伝えないと他人は可笑しさを感じる。

# 2019/10/11
## 生活習慣
- 22時ごろ布団に入っても寝れない。
	- 以前試したメラトニンは効果があった気がしたが手に入れるのが面倒。日本のサイトで買うと高い……
- 目標：タンパク質摂取量、 61 (体重：kg)×2.3= 140g
- 今飲んでいるプロテイン4杯でタンパク質26g  
	- 1日に朝夜で52g摂取。 
	- 残り98gほど欲しい。食事は昼・夜のみなので1食49g。 



# 2019/10/10
## Jquery
### ajax():ajaxメソッド(成功はdone、失敗はfail)による非同期通信の書式
	$.ajax({
	  type: リクエストタイプ,
	  url:  リクエスト送信先のURL,
	  data: URLのクエリ（パラメータ）,
	}).done(function(data, textStatus, jqXHR){
	  // 成功の場合の処理
	}).fail(function(jqXHR, textStatus, errorThrown){
	  // エラーの場合処理
	});
[ajax()：ajaxメソッド(成功はdone、失敗はfail)による非同期通信](http://karashidaimyojin.com/jquery/ajax-ajax/)

## エレメントとは
- HTML や XML 文書における、要素（タグ）
- ブラウザ画面上に配置して表示できる、DOM オブジェクト

### タグ（要素）はエレメントとなる

	<span>あいうえお</span>
	<div>かきくけこ</div>
	<img src="http://example.com/test.jpg">


### エレメントは、アトリビュート（属性）を管理することができます。
> - 以下のidやwidth,height,srcのこと

	<span id="aaa">あいうえお</span>
	<div width="300" height="200">かきくけこ</div>
	<img src="http://example.com/test.jpg">

### インラインスタイルについて
- エレメントは、スタイル属性（インラインスタイル）を保有。
- スタイル属性を使用すると、エレメントごとに、個別にスタイルを設定することができます。
	<div style="color: #f22; background-color: #fcc; width: 400px; height: 300px;">
		あいうえお
	</div>
- [スタイルについて](https://hakuhin.jp/js/style_declaration.html)

### document.createElement('tr');

  // 新しい div 要素を作成します 
  var newDiv = document.createElement("div"); 
  // いくつかの内容を与えます 
  var newContent = document.createTextNode("Hi there and greetings!"); 
  // テキストノードを新規作成した div に追加します
  newDiv.appendChild(newContent);  




# 2019/10/04
## 自習


### 本日行ったpaizaの問題
- D136:空港の呼称
- D135:【キャンペーン問題】多角形の調査
- D134:タイトルの長さ
- D120:鉛筆の数
- D010:Eメールアドレス
- D081:【キャンペーン問題】家族で分ける

	
>nextLine( )メソッドは空白(スペース)を含む文字列を取得することができます。  
一方next( )メソッドは空白までの文字列を取得します。

資金X円
上昇前A円
上昇後B円

int X
 ((X/A)* B - (X/A) * A)
 



### substring

int num = 1234567

num.substring(x,y)
x+1番目の文字列から
y番目の文字まで切り出す

num.substring(1,4)



# 2019/10/02
## 自習
### 復習
#### 本知識  
1. メソッドの引数が同じ型の場合可変長引数が使える

	String method (String a , int .....math){
	//.....が渡せる引数の数
	}

2. Javadoc
HTMLでのドキュメントとしてかける。

	/**
	*「ここにかく」
	*/

#### 015-Javaの基本-配列のネスト
実行すると
90  
70  
になる。  
[][]の一つ目の[]は三つある{}のどれかを指し示し、二つ目は{}内で
何番目かをさす。  

	    public static void main(String[] args) {
	        int score[][] = {{ 100, 80, 90, 90 },
	                            { 90, 90, 90, 90 },
	                            { 60, 90, 80, 70 } };
	        System.out.println(score[0][3]);
	        System.out.println(score[2][3]);
	    }

#### .lengthについて
配列名.lengthで配列の要素数を取得する。

	int n[] = {18, 29, 36, 12};
	System.out.println(n.length);
#### 多次元配列の場合、  
①以下の場合  
2  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num.length);

②以下の場合  
3  
3  

	int num[][] = {{1, 3, 5}, {2, 4, 6}};
	System.out.println(num[0].length);
	System.out.println(num[1].length);

さらに配列のネストが深くなるとnum[i][j].lengthになる？
	
#### newについて
newがインスタンスの生成時にクラス名 オブジェクト名= new クラス名()で使用することは理解しているが、 

	ABC abc = new ABC();

配列の宣言時にも使用することができる。

	int abc[];	//またはint[] abc;
	abc = new int[5]

配列の宣言とインスタンスの生成に同じnewを使う理由がよくわからんので調べた。

[Let's プログラミング](https://www.javadrive.jp/start/array/index2.html)
>変数の場合は宣言するだけで一つの値を格納できる場所が確保されましたが、  
配列の場合では値を格納する場所を必要な数だけ後から確保する必要があります。  
場所を確保するにはnew演算子を使って次のように行います。  

宣言ではなく値を格納する場所を確保しているらしい。


[働いたら負け](http://mikado.hatenablog.jp/entry/2014/06/07/170407)
>”new”が何を表すのか一言で言うとメモリ内に変数（コンストラクタ）を
扱うための領域（オブジェクト領域）を作成します。
	String array = new String[3];
変数の宣言でarrayを扱う領域が確保される。
newString[3]で実データを扱うための領域を新たにメモリ内に確保。
確保した領域の場所をarrayに代入して、arrayが配列として使える。


[Javaでインスタンスを使う方法【初心者向け】](https://techacademy.jp/magazine/17543)

	PersonalInfo p1 = new PersonalInfo();
newをすることでメモリ内にPersonalInfoクラスと同じ構造の領域を確保され、
その領域をp1と呼ぶ。

- 結論：newはメモリの領域を確保する


#### 016-Javaの基本-配列のネストとfor文


	public class ExampleArrayNestFor {
	    public static void main(String[] args) {
	         int score[][] = { { 100, 80, 90, 90 },
	                             { 90, 90, 90, 90 },
	                             { 60, 90, 80, 70 } };
	         String label[] = { "Tom", "John", "Mary" };
	         for (int i = 0; i < score.length; i++) {
	              System.out.print(label[i] + "'s score:");
	              for (int j = 0; j < score[i].length; j++) {
	                   System.out.print(score[i][j] + " ");
	              }
	              System.out.println();
	         }
	    }
	}

	
#### 017-Javaの基本-mainメソッドの引数

メインメソッドに引数を指定して渡すことができる。

	public static void main(String[] args){
	}
mainメソッドはString型配列の変数argsを引数として受け取る。
javaファイルを呼び出す際に値を入力することで
argsとしてうけとれる。

	java クラスファイル名 値1 値2 ..
コマンドプロンプトで以下の文を入力
	java クラスファイル名 値1 値2 
	
二つの値を記載して入力すると合計した値が計算される。


	public class MainMethodArgument {
	     public static void main(String[] args) {
	          if (args.length != 2) {
	               System.out.println("Please set two arguments.");
	               System.exit(0);
	          }
	          int data1 = Integer.parseInt(args[0]);
	          int data2 = Integer.parseInt(args[1]);
	          System.out.println(data1 + data2);
	     }
	}
#### 025-オブジェクト指向の基本-メソッドのオーバーロード
- 同じメソッド名でも引数を変えることで別の記載を使用することができる。


	public class BasicClass {
	     public static void main(String[] args) {
	          Product product1 = new Product();
	          System.out.println(product1.getPrice());
	          Product product2 = new Product();
	          System.out.println(product2.getPrice(10));
	     }
	}


	class Product {
	     private int price = 10000;

	     public int getPrice() {
	          return this.price;
	     }

	     public int getPrice(double rate) {
	          return (int) (this.price * (100 - rate) / 100);
	     }
	}
#### 028-オブジェクト指向の基本-クラス変数とクラスメソッド


public class BasicClass {
     public static void main(String[] args) {
          Product product1 = new Product("pencil", 100);
          Product product2 = new Product("eraser", 60);
          System.out.println(Product.getProductCount());
     }
}

class Product {
     private String productName;
     private int price;
     private static int count = 0;

     public Product(String productName, int price) {
          this.productName = productName;
          this.price = price;
          count++;
     }

     public static int getProductCount() {
          return count;
     }
}

# 2019/10/01
## 自習

	package main;

	import java.util.Timer;
	import java.util.TimerTask;

	public class SampleTimer{

		public class SampleTimer{

			public static void main(String[] args){
				System.out.println("タスクを3秒後に実行されるようにセットしました。");
				//ここの記載方法が不明！！なによこのかきかた
				TimerTask task = new TimerTask(){
					public void run(){
						System.out.println("タスクが実行されました");
					}
				};

				Timer timer = new Timer();
				timer.schedule(task,3000);
			}
	
## アサートの失敗
システムパスの信号線において、それが有効な状態にあることをアサートという  
無効な状態にあることをネゲートという  

何故そんな言葉があるのか、それは以下の理由による。  
信号線が有効(オン)になった状態と無効(オフ)になった状態を実際の  
電気回路で実現する場合、  
1. 電圧レベルの高い状態をオン、低い状態をオフ  
1. 電圧レベルの低い状態をオン、高い状態をオフ  
上記の二通りがある。 
実際の電圧レベルの信号の状態で言い表すことは  
ややこしくなってしまうので、有効か無効かを表す言葉がある  

# 2019/09/20
## 自習
### java復習
復習cast
変換が微妙なので再度復習

	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = i / j;

		System.out.println("result = " + result)
この場合実行すると  
result = 3.0になる  
resultの型がfloatなので3.3333になりそうだが、  
計算している変数がともにintのため、計算結果もint型になり切り捨てられる。  
小数点以下を計算したいのであれば変数i,jをfloat型で宣言する。  
  
キャスト変換を利用するのであれば  
	public static void main(String[] args) {
		int i = 10;
		int j = 3;
		float result = (float)i /(float) j;

		System.out.println("result = " + result)
上記のようになる。(型)を変数名の前に着ける。  






for文は覚えている？  
for( i = 0 ; i<10 ; i++){

}
拡張for文は？
拡張for文とは配列のためのfor文。
以下のようになる
	for(データ型 変数名:配列名){
	}
	
	String [] names = ("John", "Kate" , "Bob"};
	for(String name : names){
		System.out.println(name);
	}

配列namesに入っている要素すべてを出力する
	
	通常のfor文で書くとすると
	
	String [] names = ("John", "Kate" , "Bob"};
	for(int i = 0; i<3;i++){
		System.out.println(names[i]
	}
	//自分でかけたぜ！



# 2019/09/20
## 自習
### java配列
	型[] 変数名 = {};

	int[] numbers = { 5,13,29};
	String[] names ={"John","Kate","Bob"};

配列の要素には前から順に「0,1,2」と番号が割り振られている

これをインデックス番号と呼ぶ。  

配列の各要素は配列名[インデックス番号]とすることで取得できる。  
	System.out.println(numbers[1]);

### 配列とfor文

配列namesの要素を全て出力するために、以下のようにいちいち全て書くのは非効率。
	①	String[] names ={"John","Kate","Bob"};
		System.out.println("Hello" + names[0]);
		System.out.println("Hello" + names[1]);
		System.out.println("Hello" + names[2]);

これを短く変更すると②になる  
	②	String[] names ={"John","Kate","Bob"};
		for(int i=0; i < 3;i++){
			System.out.println("Hello" + names[i]);
		}  
拡張性を増やすならば？要素数が増えても対応できるようにしよう。  
	③	String[] names ={"John","Kate","Bob"};
		for(int i=0; i< names.length;i++){
			System.out.println("Hello" + names[i]);
		}
# 2019/09/18
## 自習

### 課題
ボーナス額の計算
//月給*ボーナス
//Scannerは「a b」の入力があった場合、1度のnext()の呼び出しで
//空白までを受け取る。よって今回の場合、1度目の呼び出しで「a」を
//2度目の呼び出しで「b」  

	import java.util.*;


	public class Main {
	    public static void main(String[] args) {！

	        Scanner sc = new Scanner(System.in);
	        int num1 = sc.nextInt();
	        int num2 = sc.nextInt();
	        
	        System.out.println(num1 * num2);
	    }
	}
### 桁計算
	package java0910;

	public class Main {
	    public static void main(String[] args) {

	/*     
		//入力値の桁を出力するプログラム
		//書いたけどだめだったやつ
		System.out.println("計算を行います");
		int a= 10000;
		int n =0;
		int keta =0;
		for(keta=a; keta<1; n ++){
		 keta=    keta/10;
		}
		System.out.print("出力結果：");
		System.out.println(n);
	*/
		//正解
		int val =100;
		int valen = String.valueOf( val).length();
		System.out.println(valen);
	}


	}
# 2019/09/17
## 自習

https://www.saycon.co.jp/touchtype/
https://www.techscore.com/tech/DesignPattern/Iterator/Iterator1.html/

## 写経
	1.1		Itaratorパターン
	繰り返す=Itarator
集約オブジェクト 
「Listクラス」
	要素としていくつかのオブジェクトを持つことができるものとする。
	このListオブジェクトが持つ要素に順番にアクセスするような場合、どのような順番で
	各要素にアクセスするのかによってさまざまな走査方法が考えられる。
	①何らかのパラメータを利用して走査
	②各オブジェクトの名前の順
	この「走査方法」はだれが提供するのか。
	Listクラスですべて提供するのは不可能。
	酔って走査方法を提供するクラスを独立させる。
	
	必要な操作方法を与えるクラスを自分で作成すし、利用することで
	柔軟な設計となる。
	
	また集約オブジェクトとして利用するクラスを変更する必要が生じた際、
	その変更が多くの部分に影響を与えるようなことが考えられる
	
	public class Student{
		private String name;
		private int sex: //男の子:1 女の子:2
		
		public Student(String name.int sex){
			this.name = name;
			this.sex = sex;
		}
		public String getName(){
			return name;
		}
		public int getSex(){
			return sex;
		}
	
生徒は名前、性別を表すメンバ変数name、sexを持ち、名前を返すgetName()メソッドと
性別を返すgetSex()メソッドを持ちます。これらの生徒を管理するために学校から先生に
名簿が支給されます。学校から与えられる名簿は以下のように記述されています。


